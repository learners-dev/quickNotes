***START WITH SORTING FIRST***

1. Longest Common Subsequence
Solution:-
public static int lcs(char[] a, char[] b) {
    int m, n;
    m = a.length;
    n = b.length;

    int[][] lengthArray = new int[m+1][n+1];
    for(int i = 0; i <= m; i++) {
        for(int j = 0; j <= n; j++) {
            if(i == 0 || j == 0) {
                lengthArray[i][j] = 0;

            } else if(a[i - 1] == b[j - 1]) {
                lengthArray[i][j] = lengthArray[i - 1][j - 1] + 1;
            } else {
                lengthArray[i][j] = max(lengthArray[i-1][j], lengthArray[i][j-1]);
            }
        }
    }
    return lengthArray[m][n];
}

2. Longest Increasing Subsequence
Solution:-
import java.util.Arrays;

class java_rough {
    public static void main(String[] args) {
        int[] receivedArray = new int[]{10, 22, 9, 33, 21, 50, 41, 60, 80};
        int lengthLongestCommonSubsequence = 0;
        int[] recordCurrentMaxForEachIndex = new int[receivedArray.length];
        Arrays.fill(recordCurrentMaxForEachIndex, 1);
        for(int i = 1; i < receivedArray.length; i++) {
            for(int j = 0; j < i; j++) {
                if(receivedArray[j] < receivedArray[i] && recordCurrentMaxForEachIndex[i] < recordCurrentMaxForEachIndex[j] + 1) {
                    recordCurrentMaxForEachIndex[i] = recordCurrentMaxForEachIndex[j] + 1;
                }
            }
            lengthLongestCommonSubsequence = Math.max(lengthLongestCommonSubsequence, recordCurrentMaxForEachIndex[i]);
        }
        System.out.println(lengthLongestCommonSubsequence);
    }
}

3. Convert one string to another using replace, remove or insert operations
Solution:-
public static int sameString(char[] a, char b) {
    int m, n;
    m = a.length;
    n = b.length;

    int[][] lengthArray = new int[m+1][n+1];
    for(int i = 0; i <= m; i++) {
        for(int j = 0; j <= n; j++) {
            if(i == 0) {
                lengthArray[i][j] = j;
            } else if(j == 0) {
                lengthArray[i][j] = i;
            } else if(a[i - 1] == b[j - 1]) {
                lengthArray[i][j] = lengthArray[i - 1][j - 1];
            } else {
                lengthArray[i][j] = 1 + min(lengthArray[i-1][j], lengthArray[i][j-1], lengthArray[i-1][j-1]);
            }
        }
    }
    return lengthArray[m][n];
}
}

4. Subset Sum to return boolean if a subset exists with target value as its sum
Solution:-
import java.util.Arrays;
public class java_rough {
    public static void main(String[] args) {
        int[] a = new int[4];
        Arrays.fill(a, 1); //Fills array with a initial value
        for(int i = 0; i < a.length; i++) {
            System.out.println(a[i]);
        }
        System.out.println("Answer is " + subsetSum(a, 3)); 
    }
    public static boolean subsetSum(int[] a, int target) {
        boolean[][] s = new boolean[a.length + 1][target + 1];
        for(int i = 0; i <= a.length; i++) {
            s[i][0] = true;
        } 
        for(int j = 1; j <= target; j++) {
            s[0][j] = false;
        }
        for(int i = 1; i <= a.length; i++) {
            for(int j = 1; j <= target; j++) {
                if((j - a[i-1]) >= 0) {
                    s[i][j] = s[i-1][j] || s[i-1][j - a[i - 1]];
                } else {
                    s[i][j] = s[i-1][j];
                }
            }
        }
        for(int i = 0; i <= a.length; i++) {
            for(int j = 0; j <= target; j++ ) {
                System.out.println(s[i][j]);
            }
        }
        return s[a.length][target];
    }

5. Knap-Sack Problem 
Solution:-
class java_rough {
    public static void main(String[] args) {
        int[] weights = new int[]{10, 20, 30};
        int[] value = new int[]{60, 100, 120};
        int sackCapacity  = 50;
        System.out.println(knapSack(weights, value, sackCapacity));
    }

    public static int knapSack(int[] weights, int[] value, int sackCapacity) {
        int[][] sampleSpace = new int[sackCapacity + 1][value.length + 1];
        
        for(int i = 0; i <= value.length; i++) {
            sampleSpace[0][i] = 0;
            sampleSpace[i][0] = 0;
        }

        for(int i = 1; i <= sackCapacity; i++) {
            for(int j = 1; j <= value.length; j++) {
                if(weights[j - 1] <= i) {
                    sampleSpace[i][j] = Math.max(value[j - 1] + sampleSpace[i - weights[j  -1]][j], sampleSpace[i - 1][j]);
                } else {
                    sampleSpace[i][j] = sampleSpace[i][j - 1];
                }
            }
        }

        return sampleSpace[sackCapacity][value.length];
    }
}


6. Reversing a LL
Solution:-
void reverse (struct node *root) {
    struct node *ptr, next, prev;
    ptr = root;
    prev = NULL;
    while(ptr != NULL) {
        next = ptr -> link;
        ptr -> link = prev;
        prev = ptr;
        ptr = next;
    }
}


7. Printing a reversed LL
Solution:-
void printReverse (struct node *ptr) {
    if(ptr == NULL) {
        return;
    }
    printReverse(ptr -> link);
    printf("%d", ptr -> data);
}

8. Tree Facts :-

- Complete Binary Tree = All levels except last are Completely filled
- Max no. of nodes at level i = 2^i;
- Max no. of nodes in tree with h levels = 2^(h + 1) - 1;
- first node index  = 2^(i - 1) + last;
- last node index = first + (2^level) - 1;


9. Insertion in BST
Solution:-
struct node *newNode(int data) {
    struct node *ptr;
    ptr = (struct node*) malloc (sizeof(struct  node));
    ptr -> data = data;
    ptr -> lc = NULL;
    ptr -> rc = NULL;
    return ptr;
}

struct node* insert(struct node *head, int data) {
    if (head == NULL) {
        head = newNode(data);
    } else if(head > data) {
        head -> lc = insert(head -> lc, data);
    } else {
        head -> rc = insert(head -> rc, data);
    }
    return head;
}

10. Minimum in BST
Solution:-
int min(struct node *head) {
    struct node *temp = head;
    while(temp->lc != NULL) {
        temp = temp -> lc;
    }
    return temp -> data;
}

11. Maximum height of tree -> Max height of Left or Right subtree
Solution:-
int maxHeight(struct node *head) {
    if(head == NULL) {
        return  -1;
    } else {
        return max(maxHeight(head -> lc), maxHeight(head -> rc)) + 1;
    }
}

12. LOT(Breadth first traversal) 
Solution:-
void lot(struct node *head) {
    struct node *temp = head;
    queue<struct node*> nodes;
    nodes.push(temp);
    while(!nodes.empty()) {
        temp = q.pop();
        printf("%d", temp -> data);
        if(temp -> lc != NULL) {
            nodes.push(temp -> lc);
        }
        if(temp -> rc != NULL) {
            nodes.push(temp -> rc);
        }
    }
}


13. Coin change problem -> The array of coin types(ex - [1,4,5]) with unlimited amount of supply for each coin 
type we need to find Minimum number of coins to get a target value.

Solution:-
import java.util.Arrays;
import java.util.Scanner;
public class java_rough {
    public static void main(String[] args) {
        int[] a = new int[3];
        int item;
        Scanner input = new Scanner(System.in);
        for(int i = 0; i < a.length; i++) {
            item = input.nextInt();
            a[i] = item;
        }
        for(int i = 0; i < a.length; i++) {
            System.out.println(a[i]);
        }
        int target = 5;
        int requiredCoins = coinChange(a, target);
        if(requiredCoins > target) {
            System.out.println("NA");
        } else {
            System.out.println("Answer is " + requiredCoins);
        }
        input.close();
    }
    public static int coinChange(int[] a, int target) {
        int[] reqCoins = new int[target + 1];
        reqCoins[0] = 0;
        for(int i = 1; i <= target; i++) {
            reqCoins[i] = target + 1;
            for(int j = 0; j < a.length; j++) {
                if(i >= a[j]) {
                    reqCoins[i] = Math.min(reqCoins[i - a[j]] + 1, reqCoins[i]);
                }
            }
        } 
        return reqCoins[target];
    }
}

14. Recursive function to check if a tree is BST.
Solution :-
int isBst(struct node *root, int max, int min) {
    if(root == NULL) {
        return 1;
    } else if(root -> data >= min && root -> data <= max && isBst(root -> lc, root -> data, min) && isBst(root -> rc, max, root -> data)) {
        return 1;
    } else {
        return 0;
    }
}

15. Deletion of node in BST.
Solution:-
import java.util.LinkedList;
import java.util.Queue;

class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public static void lot(node root) {
            Queue<node> queue = new LinkedList<>();
            queue.add(root);
            node temp;
                while(!queue.isEmpty()) {
                    temp = queue.poll();
                    System.out.print(temp.value + ", ");
                    if(temp.lc != null) {
                        queue.add(temp.lc);
                    }

                    if(temp.rc != null) {
                        queue.add(temp.rc);
                    }
                }
                System.out.println("lot traversal");
        }

        public static node deleteNode(node root, int targetValue) {
            node temp = find(root, targetValue);
            if(temp == null) {
                System.out.println("Value not present");
                return root;
            } else {
                if(temp.rc == null && temp.lc == null) {
                    System.out.println("node to be deleted has no children");
                    temp = null;
                } else if (temp.rc == null) {
                    System.out.println("node to be deleted has one child, " + temp.lc.value);
                    temp = temp.lc;
                } else if(temp.lc == null) {
                    System.out.println("node to be deleted has one child, " + temp.rc.value);
                    temp = temp.rc;
                } else {
                    System.out.println("node to be deleted has both children, " + temp.lc.value + ", " + temp.rc.value);
                    node temp2 = temp.rc;
                    node parent = null;
                    while(temp2.lc != null) {
                        parent = temp2;
                        temp2 = temp2.lc;
                    }
                    temp.value = temp2.value;
                    if(parent != null) {
                        parent.lc = temp2.rc;
                    }
                    System.out.println("inorder Successor, " + temp.value);
                }
                return root;
            }
        }

        public static node find(node root, int targetValue) {
            if(root == null) {
                return root;
            } else if(root.value == targetValue) {
                System.out.println("found value, " + root.value);
                return root;
            } else {
                System.out.println("reached node, " + root.value);
                if(root.value < targetValue) {
                    return find(root.rc, targetValue);
                } else {
                    return find(root.lc, targetValue);
                }
            }
        }
    }
    public static void main(String[] args) {
        node root = new node(10);
        root.insert(root, 5);
        root.insert(root, 15);
        root.insert(root, 3);
        root.insert(root, 9);
        root.insert(root, 11);
        root.insert(root, 20);
        root.insert(root, 4);
        root.insert(root, 7);
        root.insert(root, 8);
        root.insert(root, 12);
        root.insert(root, 16);

        node.lot(root);

        root = node.deleteNode(root, 5);

        node.lot(root);
    }
}

16. Dynamic implementation of Fibonacci series.
Solution:-
public static int fibo(int n) {
        if(n <= 1) {
            return 0;
        } else {
            int[] values = new int[n];
            int t = 2;
            values[0] = 0;
            values[1] = 1;
            if(n <=2) {
                return values[n - 1];
            }
            while(t < n) {
                values[t] = values[t-1] + values[t-2];
                t++;
            }
            return values[n - 1];   
        }
    }

17. Recursive implementation of Fibonacci series.
Solution:-
public static int fibo(int n) {
    if(n <= 1) {
        return 0;
    } else if(n == 2) {
        return 1;
    } else {
        return fibo(n - 1) + fibo(n -2);
    }
}

18. First non - repeting character

import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;

import com.sun.javafx.collections.MappingChange.Map;
public class java_rough {

    public static class character {
        public int index;
        public int frequency;

        public character(int index) {
            this.index = index;
            frequency = 1;
        }

        public void increaseFrequency() {
            this.frequency++;
        }
    }
    public static void main(String[] args) {
        char [] word = new char[] {'a', 'c', 'b', 'h', 'c', 'b', 'h','g', 'a'};
        HashMap<Integer, character> record = new HashMap<>();
        int temp;
        for(int i = 0; i < word.length; i++) {
            temp = (int) word[i];
            if(!record.containsKey(temp)) {
                character ch = new character(i);
                record.put(temp, ch);
            } else {
                record.get(temp).increaseFrequency();
            }
        }

        for(int i = 0; i < word.length; i++) {
            temp = (int) word[i];
            if(record.get(temp).frequency == 1) {
                System.out.println(word[i]);
                return;
            }
        }
    }
}


ALTERNATE APPROACH

class java_rough {
    public static void main(String[] args) {
        String word = "ADBCGHIZEFKJLADTVDERFSWVGHQWCNOPENSMSJWIERTFB";
        int [] frequency = new int[26];
        int temp, minIndex;
        minIndex = word.length();

        for(int i = 0; i < 26; i++) {
            frequency[i] = -1;
        }
        
        for(int i = 0; i < word.length(); i++) {
            temp = (int) word.charAt(i);
            temp -=65;

            if(frequency[temp] == -1) {
                frequency[temp] = i;
            } else {
                frequency[temp] = -2;
            }  
        }

        for(int i = 0; i < 26; i++) {
            if(frequency[i] >= 0 && minIndex > frequency[i]) {
                minIndex = frequency[i];
            }
        }

        System.out.println(word.charAt(minIndex));
    }

19. Printing biggest number based on elements in array 

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Scanner;

import com.sun.javafx.collections.MappingChange.Map;
public class java_rough {
     public static void main(String[] args) {
        int[] numbers = new int[]{1, 34, 3, 98, 9, 76, 45, 4};
        ArrayList<String> allNumbers = new ArrayList<>();
        String temp;
        for(int i = 0 ;i < numbers.length; i++) {
            temp = String.valueOf(numbers[i]);
           allNumbers.add(temp);
        }

        Collections.sort(allNumbers, new Comparator<String>() {
            @Override
            public int compare(String o, String p) {
                String X, Y, XY, YX;
                X = p;
                Y = o;
                XY = X + Y;
                YX = Y + X;
                System.out.println(XY + " and " + YX);
                if(XY.compareTo(YX) > 0) {
                    return -1;
                } else {
                    return 1;
                }
            }
        });
        for(int i = allNumbers.size() - 1; i >= 0; i--) {
            System.out.print(allNumbers.get(i));
        }
    }
}

20. Maximum average marks for given students

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Scanner;

import com.sun.javafx.collections.MappingChange.Map;
public class java_rough {
     public static void main(String[] args) {
        String[][] scores = new String[][] {{"jerry","65"}, {"bob","1"}, {"jerry","23"},{"Eric","23"}, {"jerry","100"},{"Eric","83"}};
        //int[][] avg = new int[1][2];
        int Maxavg = 0;
        int temp;

        HashMap<String, int[][]> record = new HashMap<>();

        for(int i = 0; i < scores.length; i++) {
            if(record.containsKey(scores[i][0])) {
                record.get(scores[i][0])[0][0]++;
                record.get(scores[i][0])[0][1] = record.get(scores[i][0])[0][1] + Integer.parseInt(scores[i][1]);
            } else {
                record.put(scores[i][0], new int[1][2]);
                record.get(scores[i][0])[0][0]++;
                record.get(scores[i][0])[0][1] = record.get(scores[i][0])[0][1] + Integer.parseInt(scores[i][1]);
            }
            System.out.println(scores[i][0] + " current avg " + record.get(scores[i][0])[0][1] / record.get(scores[i][0])[0][0]);
        }

        for(int i = 0; i < record.size(); i++) {
            temp = record.get(scores[i][0])[0][1] / record.get(scores[i][0])[0][0];
            if(temp > Maxavg) {
                Maxavg = temp;
            }
        }

        System.out.println(Maxavg);
    }
}

21. Maximum repeating substring with same character

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Scanner;

import com.sun.javafx.collections.MappingChange.Map;
public class java_rough {
     public static void main(String[] args) {
     String sample = "aaabccddddaad";
     char[] sampleArray = sample.toCharArray();

     int[] frequency = new int[26];
     int temp, count, max;
     max = 0;
     temp = 0;
     count = 0;
     char c = 'a';
     int i = 0;
     while(i < sample.length() - 1) {
         temp = (int) sampleArray[i] - 97;
         if(sampleArray[i] == sampleArray[i + 1]) {
            count++;
            i++;
            if(count > frequency[temp]) {
                frequency[temp] = count;
            }
         } else {
             i++;
             count = 0;
         }
    }

     for(i = 0; i < sample.length(); i++) {
        temp = (int) sampleArray[i] - 97;
        if(max < frequency[temp]) {
            max = frequency[temp];
            c = (char) (temp + 97);
        }
     }
     System.out.println(c + " repeats " + (max + 1) + " times");
    }
}

22. Water Trapping problem

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Scanner;

import com.sun.javafx.collections.MappingChange.Map;
public class java_rough {
     public static void main(String[] args) {
     int[] elevation = new int[]{3, 0, 0, 2, 0, 4};
     int leftIndex, rightIndex, leftMax, rightMax, result;
     leftIndex = 0;
     rightIndex = elevation.length - 1;
     leftMax = 0;
     rightMax = 0;
     result = 0;

     while(leftIndex <= rightIndex) {
         if(elevation[leftIndex] < elevation[rightIndex]) {
             if(elevation[leftIndex] > leftMax) {
                 leftMax = elevation[leftIndex];
             } else {
                result += leftMax - elevation[leftIndex];
             }
             leftIndex++;
         } else {
            if(elevation[rightIndex] > rightMax) {
                rightMax = elevation[rightIndex];
            } else {
               result += rightMax - elevation[rightIndex];
            }
            rightIndex--;
         }
     }

     System.out.println(result);
    }
}

23. Printing Anagrams together

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Scanner;

import com.sun.javafx.collections.MappingChange.Map;
public class java_rough {
    public static void main(String[] args) {
        String[] words = new String[]{"cat", "dog", "act", "tac", "god"};
        char[] temp = new char[]{'a'};
        String temp1;
        HashMap<String, ArrayList<String>> record = new HashMap<>();
        for(int i = 0; i < words.length; i++) {
            temp = words[i].toCharArray();
            Arrays.sort(temp);
            temp1 = String.valueOf(temp);
            System.out.println(temp1);
            if(record.containsKey(temp1)) {
                record.get(temp1).add(words[i]);
            } else {
                record.put(temp1, new ArrayList<String>());
                record.get(temp1).add(words[i]);
            }
        }
        
        for(String key : record.keySet()) {
            System.out.println(record.get(key));
        }
    }
}


24. Josephus Problem

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Scanner;
import com.sun.javafx.collections.MappingChange.Map;

public class java_rough {
    public static void main(String[] args) {
        int n = 14;
        int k = 2;

        int[] dead = new int[n];
        int count = 0;
        int index = k - 1;

        while(count < n - 1) {
            if(dead[index] == 2) {
                index = (index + 1) % n;
            } else {
                dead[index] = 2;
                count++;
                index = (index + k) % n;
            }
        }

        for(int i = 0; i < n; i++) {
            //if(dead[i] == 0) {
                System.out.println("Place is " + dead[i]);
            //}
        }
    }
}

25. Java lot 

import java.util.LinkedList;
import java.util.Queue;

class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public void lot(node root) {
            Queue<node> queue = new LinkedList<>();
            queue.add(root);
            node temp;
            while(!queue.isEmpty()) {
                temp = queue.remove();
                System.out.println(temp.value);
                if(temp.lc != null) {
                    queue.add(temp.lc);
                }
                if(temp.rc != null) {
                    queue.add(temp.rc);
                }
            }
        }
    }

    public static void main(String[] args) {
        node root = new node(2);
        root.insert(root, 1);
        root.insert(root, 3);
        root.insert(root, 5);
        root.insert(root, 4);
        root.insert(root, 2);
        root.insert(root, 6);
        root.lot(root);
    }
}

26. Getting longest word from dictionary made from given characters
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Arrays;

class java_rough {
    public static void main(String[] args) {
        String word = "estofgso";
        String[] dict = new String[]{"to", "too", "toe", "toes", "stgge", "abcdef"};
        int k , j, count, max;
        HashMap<Integer, ArrayList<String>> record = new HashMap<>();
        String t;
        max = 0;
        char[] temp = word.toCharArray();
        Arrays.sort(temp);
        word = String.valueOf(temp); 
        

        for(int i = 0; i  < dict.length; i++) {
            j = 0;
            k = 0;
            count = 0;
            temp = dict[i].toCharArray();
            Arrays.sort(temp);
            t = String.valueOf(temp);
            while(j < dict[i].length() && k < word.length()) {
                if(t.charAt(j) == word.charAt(k)) {
                    j++;
                    k++;
                    count++;
                } else if(t.charAt(j) > word.charAt(k)) {
                    k++;
                } else {
                    j++;
                }
            }
            System.out.println(count);
            if(!record.containsKey(count)) {
                record.put(count, new ArrayList<String>());
            }
            record.get(count).add(dict[i]);
            if(count > max) {
                max = count;
            } 
        }

        for(int i = 0; i < record.get(max).size(); i++) {
            System.out.println(record.get(max).get(i));
        }
    }
}

27. Getting ways to get upstairs given number of stairs and allowed steps.

class java_rough {
    public static void main(String[] args) {
        int steps = 4;
        int j;
        int[] allowed = new int[]{1, 2};
        int[] ways = new int[steps + 1];
        ways[0] = 1;
        int total;
        for(int i = 1; i <= steps; i++) {
            j = 0;
            total = 0;
            while(j < allowed.length) {
                if(i >= allowed[j]) {
                    total += ways[(i - allowed[j])];
                }
                j++;
            }
            ways[i] = total;
        }
        System.out.println(ways[steps]);
        }
}

28. Spiral reading of matrix

class java_rough {
    public static void main(String[] args) {
        int[][] array = new int[][]{{1,2,3},{2,4,5},{4,4,5}};
        int i, j, start, end;
        start = 0;
        end = array.length;
        i = 0;
        j = 0;
        while(start <= end) {
            for(j = start; j <= end - 1; j++) {
                System.out.print(array[i][j] + ", ");
            }
            j--;
            for(i = start + 1; i < end - 1; i++) {
                System.out.print(array[i][j] + ", ");
            }
            for(j = end - 1; j > start; j--) {
                System.out.print(array[i][j] + ", ");
            }
            for(i = end - 1; i > start; i--) {
                System.out.print(array[i][j] + ", ");
            }
            System.out.println(" ");
            start++;
            end--;
            i = start;
        }
    }
}

29. Decimal representation of fraction

import java.util.HashMap;

class java_rough {
    public static void main(String[] args) {
        int num, deno, rem;
        num = 50;
        deno = 22;
        boolean repeating = false; 
        String result = "";
        HashMap<Integer, Integer> record = new HashMap<>();

        result += String.valueOf(num/deno);
        result += ".";
        rem = (num % deno) * 10;

        while(!repeating && rem > 0) {
            if(record.containsKey(rem)) {
                repeating = true;
                System.out.print(result.substring(0,record.get(rem)));
                System.out.println("(" + result.substring(record.get(rem), result.length()) + ")");
            } else {
                record.put(rem, result.length());
                result += String.valueOf(rem / deno);
                rem = (rem % deno) * 10;
            }
        }
        if(!repeating) {
            System.out.println(result);
        }
    }
}



30. Zigzag traversal of Tree

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public void lot(node root) {
            Queue<node> queue = new LinkedList<>();
            queue.add(root);
            node temp;
            while(!queue.isEmpty()) {
                temp = queue.remove();
                System.out.println(temp.value);
                if(temp.lc != null) {
                    queue.add(temp.lc);
                }
                if(temp.rc != null) {
                    queue.add(temp.rc);
                }
            }
        }

        public void zigZag(node root) {
            Stack<node> currentStack = new Stack<>();
            Stack<node> nextStack = new Stack<>();
            boolean r2l = true;
            Stack<node> temp;
            node tempNode;
            currentStack.add(root);
            while(!currentStack.isEmpty()) {
                tempNode = currentStack.pop();
                System.out.println(tempNode.value);
                if(r2l) {
                    if(tempNode.lc != null) {
                        System.out.println("lc pushed "+ tempNode.lc.value);
                        nextStack.push(tempNode.lc);
                    }
                    if(tempNode.rc != null) {
                        System.out.println("rc pushed "+ tempNode.rc.value);
                        nextStack.push(tempNode.rc);
                    }
                } else {
                    if(tempNode.rc !=null) {
                        System.out.println("rc pushed "+ tempNode.rc.value);
                        nextStack.push(tempNode.rc);
                    }
                    if(tempNode.lc != null) {
                        System.out.println("lc pushed "+ tempNode.lc.value);
                        nextStack.push(tempNode.lc);
                    }
                }
                if(currentStack.isEmpty()) {
                    temp = currentStack;
                    currentStack = nextStack;
                    nextStack = temp;
                    r2l = !r2l;
                    System.out.println("Swapped");
                }
            }
            
        }
    }

    public static void main(String[] args) {
        node root = new node(10);
        root.insert(root, 4);
        root.insert(root, 9);
        root.insert(root, 12);
        root.insert(root, 18);
        root.insert(root, 1);
        root.insert(root, 6);
        root.insert(root, 13);
        root.lot(root);

        System.out.println("Zig-Zag traversal");
        
        node root1 = new node(10);
        root1.insert(root1, 4);
        root1.insert(root1, 9);
        root1.insert(root1, 12);
        root1.insert(root1, 18);
        root1.insert(root1, 1);
        root1.insert(root1, 6);
        root1.insert(root1, 13);
        root1.zigZag(root1);
    }
}

31. Binary Search of sorted array

import java.util.Arrays;

class java_rough {
    public static void main(String[] args) {
        int[] numbers = new int[]{1,5,3,2,7,4};
        int low, high, mid, target, iterations;
        low = 0;
        high = numbers.length - 1;
        target = 1;
        iterations = 0;
        Arrays.sort(numbers);
        while(low <= high) {
            mid = (high + low) / 2;
            System.out.println(mid);
            if(numbers[mid] > target) {
                high = mid - 1;
                iterations++;
            } else if(numbers[mid] < target) {
                low = mid + 1;
                iterations++;
            } else {
                iterations++;
                System.out.println("Found in " + iterations + " iterations");
                return;
            }
        }
        System.out.println("Finished searching not found");
    }
}

32. Finding first occurance element using Binary searching

import java.util.Arrays;

class java_rough {
    public static void main(String[] args) {
        int[] numbers = new int[]{1,1,5,4,6,3,2,4,7,4};
        int low, high, mid, target, index;
        low = 0;
        index = -1;
        high = numbers.length - 1;
        target = 4;
        Arrays.sort(numbers);
        while(low <= high) {
            mid = (high + low) / 2;
            if(numbers[mid] > target) {
                high = mid - 1;
            } else if(numbers[mid] < target) {
                low = mid + 1;
            } else {
                index = mid;
                high = mid - 1;
            }
        }
        if(index >= 0) {
            System.out.println("Found first at index -> " + index);
        } else {
            System.out.println("Finished searching not found");
        }
    }
}


33. Finding out how many times a Sorted array has been Circulary rotated

import java.util.Arrays;

class java_rough {
    public static void main(String[] args) {
        int[] numbers = new int[]{2,3,4,5,6,1};
        int low, high, mid, next, prev;
        low = 0;
        high = numbers.length - 1;
        while(low <= high) {
            mid = (high + low) / 2;
            next = (mid + 1) % numbers.length;
            prev = (mid + numbers.length + -1) % numbers.length;
            System.out.println(prev + " , " + mid + " , " + next);
            if(numbers[mid] < numbers[next] && numbers[mid] < numbers[prev]) {
                System.out.println("Array has been rotated -> " + mid + " times");
                return;
            } else if(numbers[mid] < numbers[high]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        System.out.println("Number not found");
    }
}

34. Finding out element in an Circulary rotated sorted array.

import java.util.Arrays;

class java_rough {
    public static void main(String[] args) {
        int[] numbers = new int[]{3,4,5,6,1,2};
        int low, high, mid, target;
        low = 0;
        target = 1;
        high = numbers.length - 1;
        while(low <= high) {
            mid = (high + low) / 2;
            if(numbers[mid] == target) {
                System.out.println("Element found at index -> " + mid);
                return;
            } else if(numbers[mid] < numbers[high]) {
                if(target > numbers[mid] && target <= numbers[high]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            } else {
                if(numbers[low] <= target && numbers[mid] > target) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
        }
        System.out.println("Number not found");
    }
}

35. Finding merge point of 2 Linked LinkedList

import java.util.Arrays;

import javax.xml.soap.Node;

class java_rough {
    public int lengthList(node root) {
        node ptr;
        int length;
        length = 0;
        ptr = root;
        while(ptr != null) {
            length++;
            ptr = ptr.next();
        }
        return length;
    }
    public node commonNode(node rootA, node rootB) {
        int lengthA, lengthB;
        lengthA = lengthList(rootA);
        lengthB = lengthList(rootB);
        Node tempA, tempB;
        if(lengthA < lengthB) {
            tempA = rootB;
            tempB = rootA;
        } else {
            tempA = rootA;
            tempB = rootB;
        }
        for(int i = 0; i < Math.abs(lengthA - lengthB); i++) {
            tempA = tempA.next();
        }

        while(tempA != null) {
            if(tempA.equals(tempB)) {
                return tempA.value();
            } else {
                tempA = tempA.next();
                tempB = tempB.next();
            }
        } 
    }
}

36. Finding largest sum in a subarray (Kadane's Algorithm)

class java_rough {
    public static void main(String[] args) {
        //int[] numbers = new int[]{-2, -3, 4, -1, -2, 1, 5, -3};
        int[] numbers = new int[]{2, 1, -3, 4, -1, 2, 1, -5, -4};
        int sum, answer;
        sum = 0;
        answer = 0;

        for(int i = 0; i < numbers.length; i++) {
            if(sum + numbers[i] > 0) {
                sum += numbers[i];
            } else {
                sum = 0;
            }
            answer = Math.max(sum, answer);
        }
        System.out.println(answer);
    }
}

37. Crisscross linked list mix of two seprate linked list.

class java_rough {
    static class node {
        int value;
        node next;

        void setValue(int value) {
            this.value = value;
        }
        void setNode(node next) {
            this.next = next;
        }

        int getValue() {
            return this.value;
        }

        node getNode() {
            return this.next;
        }
    }

    public static node crisscross(node root_1, node root_2) {
        node ptr_1, ptr_2, next_1, next_2;
        ptr_1 = root_1;
        ptr_2 = root_2;
        while(ptr_1 != null) {
            next_1 = ptr_1.getNode();
            next_2 = ptr_2.getNode();
            ptr_1.setNode(ptr_2);
            ptr_1.getNode().setNode(next_1);
            ptr_1 = next_1;
            ptr_2 = next_2;
        }
        return root_1;
    }

    public static void main(String[] args) {
        node n1 = new node();
        node n2 = new node();
        node n3 = new node();
        node m1 = new node();
        node m2 = new node();
        node m3 = new node();

        n1.setValue(1);
        n1.setNode(n2);

        n2.setValue(2);
        n2.setNode(n3);
        
        n3.setValue(3);
        n3.setNode(null);

        m1.setValue(4);
        m1.setNode(m2);

        m2.setValue(5);
        m2.setNode(m3);
        
        m3.setValue(6);
        m3.setNode(null);

        node ptr_1 = crisscross(n1, m1);

        while(ptr_1 != null) {
            System.out.println(ptr_1.getValue());
            ptr_1 = ptr_1.getNode();
        }
    }
}

38. Create stack with push, pop and findMax functionality in O(1)

import java.util.Scanner;
import java.util.Stack;

class java_rough {
    static class node {
        int value;
        int max;

        node(int value, int max) {
            this.value = value;
            this.max = max;
        }

        int getValue() {
            return this.value;
        }

        int getMax() {
            return this.max;
        }
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        Stack<node> stack = new Stack<>();
        int max = 0;
        int value;
        node temp;
        System.out.println("Select operation code\n1. Push\n2. Pop\n3. Max");
        int choice = input.nextInt();
        while(choice != 0) {
            switch(choice) {
                case 1:
                System.out.println("Enter value");
                value = input.nextInt();
                if(value > max) {
                    stack.push(new node(value, max));
                    max = value;
                } else {
                    stack.push(new node(value,max));
                }
                break;

                case 2:
                temp = stack.pop();
                if(temp.getValue() == max) {
                    max = temp.getMax();
                }
                System.out.println("value returned " + temp.getValue());
                break;
                
                case 3:
                System.out.println("Max value is " + max);
                break;

                default :
                return;
            }
            System.out.println("Select operation code\n1. Push\n2. Pop\n3. Max");
            choice = input.nextInt();
        }
        input.close();
    }
}

39. Finding if loop exists in ll and its starting point

class java_rough {
    static class node {
        int value;
        node next;

        void setValue(int value) {
            this.value = value;
        }
        void setNode(node next) {
            this.next = next;
        }

        int getValue() {
            return this.value;
        }

        node getNode() {
            return this.next;
        }
    }
     public static void main(String[] args) {
        node n1 = new node();
        node n2 = new node();
        node n3 = new node();
        node n4 = new node();
        

        n1.setValue(1);
        n1.setNode(n2);

        n2.setValue(2);
        n2.setNode(n3);
        
        n3.setValue(3);
        n3.setNode(n4);

        n4.setValue(4);
        n4.setNode(n2);

        node slow, fast;
        slow = n1;
        fast = n1;
        while(fast != null) {
            slow = slow.getNode();
            fast = fast.getNode().getNode();
            if(slow.equals(fast)) {
                break;
            }
        }
// logic to find starting node of loop
        slow = n1;
        while(!slow.equals(fast)) {
            slow = slow.getNode();
            fast = fast.getNode();
        }
        System.out.println("The node value where loop starts is " + fast.getValue());
    }
}

40. Prime factorization 

class java_rough {
    public static void main(String[] args) {
        int number;
        number = 54;

        for(int i = 2; i < Math.sqrt(number); i++) {
            while(number % i == 0) {
                System.out.print(i+"\t");
                number /= i;
            }
        }

        if(number > 2) {
            System.out.print(number);
        }
    }
}

41. Number of ones in binary representation of a number

class java_rough {
    public static void main(String[] args) {
        int number = 9;
        int ones = 0;
        while(number > 0) {
            ones += number & 1;
            number >>=1;
        }
        System.out.println(ones);
    }
}

42. nth node from end in ll in one iterations

class java_rough {
    static class node {
        int value;
        node next;

        void setValue(int value) {
            this.value = value;
        }
        void setNode(node next) {
            this.next = next;
        }

        int getValue() {
            return this.value;
        }

        node getNode() {
            return this.next;
        }
    }
     public static void main(String[] args) {
        node n1 = new node();
        node n2 = new node();
        node n3 = new node();
        node n4 = new node();

        int nth = 4;
        

        n1.setValue(1);
        n1.setNode(n2);

        n2.setValue(2);
        n2.setNode(n3);
        
        n3.setValue(3);
        n3.setNode(n4);

        n4.setValue(4);
        n4.setNode(null);

        node slow, fast;
        slow = n1;
        fast = n1;

        for(int i = 0; i < nth ; i++) {
            fast = fast.getNode();
        }

        while(fast != null) {
            slow = slow.getNode();
            fast = fast.getNode();
        }
        System.out.println("the " + nth + " node from last is " + slow.getValue());
    }
}

43. Arranging ll in i -> (n - i) manner where i goes from 0 to n/2 and n is length of list

class java_rough {
    static class node {
        int value;
        node next;

        void setValue(int value) {
            this.value = value;
        }
        void setNode(node next) {
            this.next = next;
        }

        int getValue() {
            return this.value;
        }

        node getNode() {
            return this.next;
        }
    }
     public static void main(String[] args) {
        node n1 = new node();
        node n2 = new node();
        node n3 = new node();
        node n4 = new node();
        node n5 = new node();

        int nth = 4;
        

        n1.setValue(1);
        n1.setNode(n2);

        n2.setValue(2);
        n2.setNode(n3);
        
        n3.setValue(3);
        n3.setNode(n4);

        n4.setValue(4);
        n4.setNode(n5);

        n5.setValue(5);
        n5.setNode(null);

        node slow, fast;
        slow = n1;
        fast = n1;

        while(fast != null && fast.getNode() != null) {
            slow = slow.getNode();
            fast = fast.getNode().getNode();
        }
        System.out.println("value of mid node = " + slow.getValue());
        node ptr, prev, next;
        ptr = slow;
        prev = null;
        while(ptr != null) {
            next = ptr.getNode();
            ptr.setNode(prev);
            prev = ptr;
            ptr = next;
        }
        System.out.println("value of mid node = " + prev.getValue());
        ptr = n1;
        slow = prev;
        while(slow != null) {
            next = ptr.getNode();
            prev = slow.getNode();
            ptr.setNode(slow);
            slow.setNode(next);
            ptr = next;
            slow = prev;
        }
        ptr = n1;
        while(ptr != null) {
            System.out.print(ptr.getValue() + " -> ");
            ptr = ptr.getNode();
        }
        System.out.println("null");
    }
}

44. Maximum Product Subarray

class java_rough {
    public static void main(String[] args) {
        int[] entries = new int[]{-2, -3, 0, -2, -40};
        int prod, result;
        prod = 0;
        result = 0;
        for(int i = 0 ; i < entries.length; i++) {
           if(entries[i] == 0) {
                prod = 0;
           } else {
               if(prod == 0) {
                   prod = entries[i];
               } else {
                   prod *= entries[i];
               }
           }
           result = Math.max(result, prod);
        }
        System.out.println(result);
    }
}


45. Rat Maze problem

class java_rough {
    public static void ratMaze(int[][] maze) {

        //This function intializes a solution matrix of same size as the maze matrix
        //and intializes value of row and column and calls recursive function that will return boolean
        int[][] solution = new int[maze.length][maze.length];
        int row, column;
        row = 0;
        column = 0;
        //calling the recursive function to solve the question
        if(solveMaze(maze, solution, row, column) == false) {
            System.out.println("There is no path");
        } else {
            printArray(solution);
            System.out.println("Is the path for reaching the end");
        }
    }

    public static boolean solveMaze(int[][] maze, int[][] solution, int row, int column) {
        //Exit condition to check if we have reached the end
        if(row == maze.length - 1 && column == maze.length - 1) {
            solution[row][column] = 1;
            return true;
        } 
        //Checking if we are at a allowed tile in matrix
        if(isValidMove(maze, row, column)) {
            //if we are we will tell our solution matrix that we are here
            solution[row][column] = 1;
            //Recursive call to function starting after taking a down step
            if(solveMaze(maze, solution, row + 1, column)) {
                return true;
            }
            //Recursive call to function starting after taking a right step
            if(solveMaze(maze, solution, row, column+1)) {
                return true;
            }
            //If still true is not returned that means we will not find path from here so we update out solution 
            //matrix
            solution[row][column] = 0;
            return false;
        }   
        return false;
    }

    public static void printArray(int[][] solution) {
        for(int i = 0; i < solution.length; i++) {
            for(int j = 0; j < solution.length; j++) {
                System.out.print(solution[i][j] + " ");
            }
            System.out.println(" ");
        }
    }

    public static boolean isValidMove(int[][] maze, int row, int column) {
        return (row <= maze.length - 1 && column <= maze.length - 1 && maze[row][column] == 1);
    }

    public static void main(String[] args) {

        //intial maze matrix
        int[][] maze = new int[][]{ { 1, 1, 1, 1 }, 
                                    { 1, 1, 0, 1 }, 
                                    { 0, 1, 0, 1 }, 
                                    { 0, 0, 0, 1 } }; 

        ratMaze(maze); //calling function to solve
    }
}

46. KMP sub-string match

class java_rough {

    public static void kmp(String data, String pattern) {
        int[] lps = new int[pattern.length()];
        lps = preProcessLongestPrefixSuffix(pattern, lps);
        int i = 0;
        int j = 0;
        while(i < data.length()) {
            if(data.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
                if(j == pattern.length() - 1) {
                    System.out.println("Match occurs at index " + (i - j));
                    j = lps[j - 1];
                }
            } else {
                if(j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
    }

    public static int[] preProcessLongestPrefixSuffix(String pattern, int[] lps) {
        lps[0] = 0;
        int length = 0;
        int i = 0;
        while(i < pattern.length() - 1) {
            if(pattern.charAt(i) == pattern.charAt(length)) {
                length++;
                i++;
                lps[i] = length;
            } else if(length != 0) {
                length = lps[length];
            } else {
                lps[i] = length;
                i++;
            }
        }
        for(i = 0; i < lps.length; i++) {
            System.err.print(lps[i] + " ");
        }
        return lps;
    }

    public static void main(String[] args) {
       String data, pattern;
       data = "AABAACAADAABAABA";
       pattern = "AABA";
       System.out.println(data + " and " + pattern);
       kmp(data, pattern);
    }
}

47. Possible paths for n*m matrix


Best case solution will be using PnC ie

(n + m - 2)! / ((n - 1)! * (m - 1)!);

DP Solution: -
class java_rough {
     public static void main(String[] args) {
        int m, n;
        m = 5;
        n = 5;
        int [][] paths = new int[m][n];
        for(int i = 0; i < m; i++) {
            paths[i][0] = 1;
        }
        for(int j = 0; j < n; j++) {
            paths[0][j] = 1;
        }
        for(int i = 1; i < n; i++) {
            for(int j = 1; j < m; j++) {
                paths[i][j] = paths[i][j - 1] + paths[i - 1][j];
            }
        }
        System.out.println("The possible solutions are " + paths[m - 1][n - 1]);

    }

48. Interface referance can hold child class object but only methods declared in the interface can be called.
EX - https://stackoverflow.com/questions/14997202/creating-object-with-reference-to-interface

49. Referance for understanding the relations between collection classes and interfaces.
EX - https://www.scientecheasy.com/2018/09/collection-hierarchy-in-java.html

50. For storing and accessing data ArrayList is better for data manipulation and removal linked list is better
as in ArrayList we internally bits are shifted but in LinkedList we can just update the referances as it is
implemented using doubly linked list internally.

51. Implementation example of priority queue with custom comparator function used for priority calculation
with random class example

package com.journaldev.collections;

import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Random;

public class PriorityQueueExample {

	public static void main(String[] args) {
		
		//natural ordering example of priority queue
		Queue<Integer> integerPriorityQueue = new PriorityQueue<>(7);
		Random rand = new Random();
		for(int i=0;i<7;i++){
			integerPriorityQueue.add(new Integer(rand.nextInt(100)));
		}
		for(int i=0;i<7;i++){
			Integer in = integerPriorityQueue.poll();
			System.out.println("Processing Integer:"+in);
		}
		
		//PriorityQueue example with Comparator
		Queue<Customer> customerPriorityQueue = new PriorityQueue<>(7, idComparator);
		addDataToQueue(customerPriorityQueue);
		
		pollDataFromQueue(customerPriorityQueue);
		
	}
	
	//Comparator anonymous class implementation
	public static Comparator<Customer> idComparator = new Comparator<Customer>(){
		
		@Override
		public int compare(Customer c1, Customer c2) {
            return (int) (c1.getId() - c2.getId());
        }
	};

	//utility method to add random data to Queue
	private static void addDataToQueue(Queue<Customer> customerPriorityQueue) {
		Random rand = new Random();
		for(int i=0; i<7; i++){
			int id = rand.nextInt(100);
			customerPriorityQueue.add(new Customer(id, "Pankaj "+id));
		}
	}
	
	//utility method to poll data from queue
	private static void pollDataFromQueue(Queue<Customer> customerPriorityQueue) {
		while(true){
			Customer cust = customerPriorityQueue.poll();
			if(cust == null) break;
			System.out.println("Processing Customer with ID="+cust.getId());
		}
	}

}

52. Total elements in a binary tree

class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public static int totalElements(node root) {
            if(root == null) {
                return 0;
            } else {
                return (1 + totalElements(root.lc) + totalElements(root.rc));
            }
        }
    }

    public static void main(String[] args) {
        node root = null;
        //node root = new node(10);
        // root.insert(root, 4);
        // root.insert(root, 9);
        // root.insert(root, 12);
        // root.insert(root, 18);
        // root.insert(root, 1);
        // root.insert(root, 6);
        // root.insert(root, 13);
        
        System.out.println("Number of elements in Binary tree are " + node.totalElements(root));
    }
}

53. Number of leaf nodes in a binary tree

class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;
        static int leafNodes = 0;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public static void totalLeaves(node root) {
            if(root == null) {
                return;
            } else if (root.lc == null && root.rc == null) {
                System.out.println(root.value + " is a leaf");
                leafNodes++;
                return;
            } else {
                totalLeaves(root.lc);
                totalLeaves(root.rc);
            }
        }
    }

    public static void main(String[] args) {
        //node root = null;
        node root = new node(10);
        root.insert(root, 4);
        root.insert(root, 9);
        root.insert(root, 12);
        root.insert(root, 18);
        root.insert(root, 1);
        root.insert(root, 6);
        root.insert(root, 13);

        node.totalLeaves(root);
        
        System.out.println("Number of elements in Binary tree are " + node.leafNodes);
    }
}

54. Checking both trees are structurally equal :-

class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public  static boolean sameStructure(node root, node root1) {
            if(root == null && root1 == null) {
                return true;
            } else if(root == null || root1 == null) {
                return false;
            } else if(root.value == root1.value 
            && sameStructure(root.lc, root1.lc) 
            && sameStructure(root.rc, root1.rc)) {
                return true;
            }
            return false;
        }

    }

    public static void main(String[] args) {
        //node root = null;
        node root = new node(10);
        root.insert(root, 4);
        root.insert(root, 9);
        root.insert(root, 12);
        root.insert(root, 18);
        root.insert(root, 1);
        root.insert(root, 16);
        root.insert(root, 13);

        node root1 = new node(10);
        root.insert(root1, 4);
        root.insert(root1, 9);
        root.insert(root1, 12);
        root.insert(root1, 18);
        root.insert(root1, 1);
        root.insert(root1, 16);
        root.insert(root1, 13);

        System.out.println("Both the trees a Structurally same = " + node.sameStructure(root, root1));
    }
}

55. Maximum sum of any level in a tree :-

import java.util.LinkedList;
import java.util.Queue;


class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public void zigZag(node root) {
            Queue<node> currentList = new LinkedList<>();
            Queue<node> nextList = new LinkedList<>();
            Queue<node> temp;
            node tempNode;
            int max = 0;
            int sum = 0;
            int level = 0;
            int maxLevel = 0;
            currentList.add(root);
            max = root.value;
            while(!currentList.isEmpty()) {
                tempNode = currentList.poll();
                sum += tempNode.value;
                if(tempNode.lc != null) {
                    nextList.add(tempNode.lc);
                }
                if(tempNode.rc != null) {
                    nextList.add(tempNode.rc);
                }
                 if(currentList.isEmpty()) {
                    temp = currentList;
                    currentList = nextList;
                    nextList = temp;
                    if(max < sum) {
                        max = sum;
                        maxLevel = level;
                    }
                    sum = 0;    
                    level++;
                }
            }
            System.out.println("Max sum is " + max + " for level " + maxLevel);
        }
    }

    public static void main(String[] args) {
        node root1 = new node(10);
        root1.insert(root1, 4);
        root1.insert(root1, 9);
        root1.insert(root1, 12);
        root1.insert(root1, 18);
        root1.insert(root1, 1);
        root1.insert(root1, 6);
        root1.insert(root1, 13);
        root1.zigZag(root1);
    }
}

56. Printing all paths  of a tree with path's sum:-

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;


class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public static void printPaths(node root, List<Integer> path, int length) {
            if(root == null) {
                return;
            }
            path.add(length, root.value);
            length++;
            if(root.lc == null && root.rc == null) {
                printArrayList(path, length);
                return;
            }
            printPaths(root.lc, path, length);
            printPaths(root.rc, path, length);
        }

        public static void printArrayList(List<Integer> path, int length) {
            int sum = 0;
            for(int i = 0; i < length; i++) {
                sum += path.get(i);
                System.out.print(path.get(i) + " -> ");
            }
            System.out.print("Has sum = " + sum + "\n");
        }

    }

    public static void main(String[] args) {
        node root1 = new node(10);
        root1.insert(root1, 4);
        root1.insert(root1, 9);
        root1.insert(root1, 12);
        root1.insert(root1, 18);
        root1.insert(root1, 1);
        root1.insert(root1, 6);
        root1.insert(root1, 13);
        List<Integer> path = new ArrayList<>();
        node.printPaths(root1, path, 0);
    }
}

57. Finding element in a row-wise and column-wise sorted 2d-array

int i = rows - 1;
int j = 0;

while(i >= 0 && j < columns) {
    if(array[i][j] > target) {
        j++;
    } else if(array[i][j] < target) {
        i--;
    } else {
        return array[i][j];
    }
}


58. Number of trailing zeroes given n!

int c = 0;
if(n < 0) {
    return -1;
} else {
    for(int i = 5; n / i > 0; i *= 5) {
        c += n / i;
    }
}
return c;

59. Longest palindromic substring present in a given string

class java_rough {
    public static void main(String[] args) {
        String input = "ababbcbba";
        int start, end, length, palindromeEnd, palindromeStart, maxLength, currentLength;
        length = input.length();
        maxLength = 1;
        palindromeStart = 0;
        palindromeEnd = 0;
        for(int i = 0; i < length; i++) {
            start = i;
            end = i + 1;
            currentLength = 1;
            while(start >= 0 && end < length && input.charAt(start) == input.charAt(end)) {
                currentLength = end - start + 1;
                start--;
                end++;
            }
            if(maxLength < currentLength) {
                maxLength = currentLength;
                palindromeStart = start + 1;
                palindromeEnd = end - 1;
            }

            start = i - 1;
            end = i + 1;
            currentLength = 1;
            while(start >= 0 && end < length && input.charAt(start) == input.charAt(end)) {
                currentLength = end - start + 1;
                start--;
                end++;
            }
            if(maxLength < currentLength) {
                maxLength = currentLength;
                palindromeStart = start + 1;
                palindromeEnd = end - 1;
            }
        }
        System.out.println("The length of longest palindromic substring is = " + maxLength);
        for(int i = palindromeStart; i <= palindromeEnd; i++) {
            System.out.print(input.charAt(i));
        }
    }
}

60. Printing all permutations of a String by Backtracking : 
1. Pass string , 0  and LENGTH OF STRING TO FUNCTION.
2. Inside permute function which is the recursive function check if lower index ==  upper index, then print th string.
3. Else run a for loop from lower index to upper index swapping lower element with ith index;
4. Call permute function again to call on this modifies string and lower + 1 index.
5. Swap back.

class java_rough {
    public static String swap(String sample, int i, int j) {
        if(i != j) {
            char temp, array[];
            array = sample.toCharArray();

            temp = array[i];
            array[i] = array[j];
            array[j] = temp;

            sample = String.valueOf(array);
        }
        return sample;
    }

    public static void permute(String sample, int lower, int upper) {
        if(lower == upper) {
            System.out.println(sample);
        } else {
            for(int i = lower; i <= upper; i++) {
                sample = swap(sample, i, lower);
                permute(sample, lower + 1, upper);
                sample = swap(sample, i, lower);
            }
        }
    }

    public static void main(String[] args) {
        String sample = "abcd";
        permute(sample, 0, sample.length() - 1);
    }
}

61. Finding max differance between array elements st smaller element comes before larger one

class java_rough {
    public static void main(String[] args) {
        int[] sample = new int[]{ 2, 13, 4, 1, 5, 16, 7};
        int maxDifferance = 0;
        int minimumElement = sample[0];

        for(int i = 1; i < sample.length; i++) {
            if(sample[i] - minimumElement > maxDifferance) {
                maxDifferance = sample[i] - minimumElement;
            }

            if(sample[i] < minimumElement) {
                minimumElement = sample[i];
            }
        }

        System.out.println("Max differance " + maxDifferance);
    }
}

62. To remove trailing and leading blank spaces in java use String.trim();

63. Finding Square root of any number 

class java_rough {
    public static void main(String[] args) {
        float square, start, end, mid, temp, counter;
        square = 50;
        start = 1;
        end = square;
        counter = 0;
        while(start <= end) {
            counter++;
            mid = (start + end) / 2;
            temp = (mid * mid);
            System.out.println(temp + ", " + mid + ", " + start + ", " + end);
            if(temp == square || counter == 40) { //Just a fail safe to avoid infinite looping
                System.out.println("The square root is " + mid);
                return;
            } else if(temp > square) {
                end = mid;
            } else {
                start = mid;
            }
        }
    }
}
TRICK FOR ROUNDING
class java_rough {
    public static void main(String[] args) {
       float n = 1.23232323f;
       System.out.println(Math.round(n*n*1000.0) / 1000.0);
    }
}
64. Calculating number of BST possible from n distinct values given
The approach uses the fact that when traversing through element in ascending order you can get elements that are going to be part 
of the right or left subtree. With that information you can calculate the number of possibilities to create BST from number of 
nodes in each of these subtrees. 
Total number of possible Binary Search Trees with n different keys (countBST(n)) = (2n)! / ((n + 1)! * n!)

class java_rough {
    public static void main(String[] args) {
        int[] keys = new int[]{1,2,3,4};
        int[] possible = new int[keys.length + 1];
        possible[0] = 1;
        possible[1] = 1;
        for(int i = 2; i < possible.length; i++) {
            possible[i] = 0;
            for(int j = 0; j < i; j++) {
                possible[i] += (possible[j] * possible[i-j-1]);
            }
        }
        System.out.println("Number of possible BS trees " + possible[keys.length]);
    }
}

65. Threaded Binary Tree - make inorder traversal faster and do it without stack and without recursion. A binary tree is made 
threaded by making all right child pointers that would normally be NULL point to the inorder successor of the node and left child
to inorder predecessor. Node structure for Threaded binary tree is represenred below.

class node {
    node rc;
    node lc;
    int value;
    int rc_flag; //to tell if node address stored is child or inorder successor
    int lc_flag; //to tell if node address stored is child or inorder predecessor
}

the lefmost leaf node's lc and rightmost leaf node's rc points to a dummy node given below :-
dummy node {
    node rc = self;
    node lc = root;
    int value = null;
    int rc_flag = 0;
    int lc_flag = 0;
}

66. Diameter of a binary tree -> It is the longest distance between any 2 nodes in a tree.

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;


class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public static int getDiameter(node root) {
            if(root == null) {
                return 0;
            }
            return Math.max(
                (1 + getMaxHeight(root.lc) + getMaxHeight(root.rc)), 
                Math.max(getDiameter(root.lc), getDiameter(root.rc))
                );
        }

        public static int getMaxHeight(node root) {
            if(root == null) {
                return 0;
            } else {
                return (1 + Math.max(getMaxHeight(root.lc), getMaxHeight(root.rc)));
            }
        }
    }

    public static void main(String[] args) {
        node root1 = new node(10);
        root1.insert(root1, 4);
        root1.insert(root1, 9);
        root1.insert(root1, 12);
        root1.insert(root1, 3);
        root1.insert(root1, 1);
        root1.insert(root1, 6);
        root1.insert(root1, 2);
        root1.insert(root1, 7);
        root1.insert(root1, 8);
       
        int diameter = node.getDiameter(root1);
        System.out.println("The Diameter is " + diameter);
    }
}

67. Returning subtree root node having exactly K leaf nodes

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;


class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public static int getRequiredRoots(node root, int k) {
            int right, left;
            if(root == null) {
                return 0;
            } else if(root.lc == null && root.rc == null) {
                return 1;
            } else {
                right = getRequiredRoots(root.lc, k);
                left = getRequiredRoots(root.rc, k);
                if(k == right + left) {
                    System.out.println(root.value);
                    return k;
                }
                return (right + left);
            }
        }
    }

    public static void main(String[] args) {
        node root1 = new node(10);
        root1.insert(root1, 4);
        root1.insert(root1, 9);
        root1.insert(root1, 12);
        root1.insert(root1, 3);
        root1.insert(root1, 1);
        root1.insert(root1, 6);
        root1.insert(root1, 2);
        root1.insert(root1, 7);
        root1.insert(root1, 8);
        root1.insert(root1, 5);
        int k = 1;
        node.getRequiredRoots(root1, k);
    }
}

68. Diagonal traversal of tree

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;


class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public static void printDiagonally(node root) {
            Queue<node> currentQueue = new LinkedList<>();
            Queue<node> nextQueue = new LinkedList<>();
            Queue<node> tempQueue;
            node temp;
            currentQueue.add(root);
            while(!currentQueue.isEmpty()) {
                temp = currentQueue.poll();
                while(temp != null) {
                    System.out.println(temp.value);
                    if(temp.lc != null) {
                        nextQueue.add(temp.lc);
                    }
                    temp = temp.rc;
                }
                if(currentQueue.isEmpty()) {
                    tempQueue = currentQueue;
                    currentQueue = nextQueue;
                    nextQueue = tempQueue;
                }
            }
        }
    }

    public static void main(String[] args) {
        node root1 = new node(10);
        root1.insert(root1, 4);
        root1.insert(root1, 9);
        root1.insert(root1, 12);
        root1.insert(root1, 3);
        root1.insert(root1, 1);
        root1.insert(root1, 6);
        root1.insert(root1, 2);
        root1.insert(root1, 7);
        root1.insert(root1, 8);
        root1.insert(root1, 5);
       
       node.printDiagonally(root1); 
    }
}


69. Finding lowest common ancestor in a tree :-

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;


class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public static node lowestCommonAncestor(node root, int value1, int value2) {
            if(root == null) {
                return null;
            } else if(root.value == value1 || root.value == value2) {
                return root;
            } else {
                node left = lowestCommonAncestor(root.lc, value1, value2);
                node right = lowestCommonAncestor(root.rc, value1, value2);

                if(left != null && right != null) {
                    System.out.println("Lowest Common ancestor is " + root.value);
                    return root;
                } else {
                    return (left != null ? left : right);
                }
            }
        }
    }

    public static void main(String[] args) {
        node root1 = new node(10);
        root1.insert(root1, 4);
        root1.insert(root1, 9);
        root1.insert(root1, 12);
        root1.insert(root1, 3);
        root1.insert(root1, 1);
        root1.insert(root1, 6);
        root1.insert(root1, 2);
        root1.insert(root1, 7);
        root1.insert(root1, 8);
        root1.insert(root1, 5);

        node.lowestCommonAncestor(root1, 1, 6);
       
    }
}


70. Vertical Traversal of tree :-

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;


class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public static HashMap<Integer, ArrayList<node>> verticalTraversal(node root, HashMap<Integer, ArrayList<node>> map) {
            preProcessing(root, map, 0);
            return map;
        }

        public static void preProcessing(node root, HashMap<Integer, ArrayList<node>> map, int horizontalDistance) {
            if(root == null) {
                return;
            } 
            if(!map.containsKey(horizontalDistance)) {
                map.put(horizontalDistance, new ArrayList<node>());
            }
            map.get(horizontalDistance).add(root);
            preProcessing(root.lc, map, horizontalDistance - 1);
            preProcessing(root.rc, map, horizontalDistance + 1);
        }
    }

    public static void main(String[] args) {
        node root1 = new node(5);
        root1.insert(root1, 3);
        root1.insert(root1, 4);
        root1.insert(root1, 2);
        root1.insert(root1, 8);
        root1.insert(root1, 6);
        root1.insert(root1, 10);
        root1.insert(root1, 9);
        root1.insert(root1, 7);
        root1.insert(root1, 12);

        HashMap<Integer, ArrayList<node>> map = node.verticalTraversal(root1, new HashMap<Integer, ArrayList<node>>());

        for(Integer i : map.keySet()) {
            System.out.print("Level " + i + " -> ");
            map.get(i).forEach(node -> System.out.print(node.value + " "));
            System.out.println("\n");
        }
    }
}

71.  For top view of tree just perform the same as above but instead of printing all print only the first value entered per index.

72. For right/left side view just print the last/first element of lot of tree respectively.

73. Finding diagonal sum of tree

import java.util.ArrayList;
import java.util.HashMap;

class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public static HashMap<Integer, Integer> verticalTraversal(node root, HashMap<Integer, Integer> map) {
            preProcessing(root, map, 0);
            return map;
        }

        public static void preProcessing(node root, HashMap<Integer, Integer> map, int horizontalDistance) {
            if(root == null) {
                return;
            } 
            if(!map.containsKey(horizontalDistance)) {
                map.put(horizontalDistance, 0);
            }
            map.put(horizontalDistance, map.get(horizontalDistance) + root.value);
            preProcessing(root.lc, map, horizontalDistance + 1);
            preProcessing(root.rc, map, horizontalDistance);
        }
    }

    public static void main(String[] args) {
        node root1 = new node(5);
        root1.insert(root1, 3);
        root1.insert(root1, 4);
        root1.insert(root1, 2);
        root1.insert(root1, 8);
        root1.insert(root1, 6);
        root1.insert(root1, 10);
        root1.insert(root1, 9);
        root1.insert(root1, 7);
        root1.insert(root1, 12);

        HashMap<Integer, Integer> map = node.verticalTraversal(root1, new HashMap<Integer, Integer>());

        for(Integer i : map.keySet()) {
            System.out.print("Diagonal Sum is" + " -> " + map.get(i));
            System.out.println("\n");
        }
    }
}

74. Storing players of match such that traversal gives order having each player in front of him player that he lost to is done by 
storing players in BST.

75. DS to store dependencies for a module are stored in Directed Acyclic Graph and doing a topological sort on it to get order
in which dependencies should be installed.

76. Reversing linked list elements k at a times

class java_rough {
    static class node {
        public int value;
        public node link;

        public node(int value) {
            this.value = value;
        }

        public static node rotateByKUnits(node start, int k) {
            int i;
            node ptr, next, prev;
            next = null;
            ptr = start;
            prev = null;
            i = 0;
            while(ptr != null && i < k) {
                next = ptr.link;
                ptr.link = prev;
                prev = ptr;
                ptr = next;
                i++;
            }

            if(next != null) {
                start.link = rotateByKUnits(next, k);
            }
            return prev;
        }
    }

    public static void main(String[] args) {
        node node1 = new node(1);
        node1.link = new node(2);
        node1.link.link = new node(3);
        node1.link.link.link = new node(4);
        node1.link.link.link.link = new node(5);
        node1.link.link.link.link.link = new node(6);
        node1.link.link.link.link.link.link = new node(7);
        node1.link.link.link.link.link = null;

        
        node ptr = node.rotateByKUnits(node1, 3);
        while(ptr != null) {
            System.out.println(ptr.value);
            ptr = ptr.link;
        }
    }
}


77. DFS in a Directed graph

 - Here vertex is first pushed to stack
 - In Topological sort vertex is pushed in stack once recursive function is completed for its children

import java.util.LinkedList;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Stack;

class java_rough {
    public static class Graph {
        public int vertices;
        public ArrayList<LinkedList<Integer>> matrix;

        public Graph(int vertices) {
            this.vertices = vertices;
            this.matrix = new ArrayList<>();
            for(int i = 0; i <= vertices; i++) {
                this.matrix.add(new LinkedList<Integer>());
            }
        }

        public void addVertice(int u, int v) {
            this.matrix.get(u).add(v);
        }

        public void DFS(int start) {
            Stack<Integer> vertices = new Stack<>();
            boolean[] visited = new boolean[this.matrix.size()];
            int temp = 0;

            vertices.push(start); 
            while(!vertices.isEmpty()) {
                temp = vertices.pop();
                if(visited[temp] != true) {
                    System.out.println(temp);
                    visited[temp] = true;
                }

                for(Integer i : this.matrix.get(temp)) {
                    if(visited[i] != true) {
                        vertices.push(i);
                    }
                }
            }
        }
    }

    public static void main(String[] args) {
        Graph graph = new Graph(5);

        graph.addVertice(0, 1);
        graph.addVertice(1, 2);
        graph.addVertice(2, 3);
        graph.addVertice(3, 3);
        graph.addVertice(0, 2);
        graph.addVertice(2, 0);

        graph.DFS(2);
    }
}

78. Topological sort in Graph

import java.util.LinkedList;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Stack;

class java_rough {
    public static class Graph {
        public int vertices;
        public ArrayList<LinkedList<Integer>> matrix;

        public Graph(int vertices) {
            this.vertices = vertices;
            this.matrix = new ArrayList<>();
            for(int i = 0; i <= vertices; i++) {
                this.matrix.add(new LinkedList<Integer>());
            }
        }

        public void addVertice(int u, int v) {
            this.matrix.get(u).add(v);
        }

        public Stack<Integer> topologicalSort(int start, HashSet<Integer> set, Stack<Integer> stack) {
            if(!set.contains(start)) {
                set.add(start);
            while(!this.matrix.get(start).isEmpty()) {
                topologicalSort(this.matrix.get(start).poll(), set, stack);
            }
            stack.push(start);
            }
            return  stack;
        }

    }

    public static void main(String[] args) {
        Graph graph = new Graph(5);

        graph.addVertice(5, 2);
        graph.addVertice(5, 1);
        graph.addVertice(4, 1);
        graph.addVertice(2, 3);
        graph.addVertice(3, 4);

        HashSet<Integer> set = new HashSet<>();
        Stack<Integer> stack = new Stack<>();
        stack = graph.topologicalSort(5,set, stack);

        while(!stack.isEmpty()) {
            System.out.println(stack.pop());
        }
    }
}

import java.util.LinkedList;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Stack;

class java_rough {
    public static class Graph {
        public int vertices;
        public ArrayList<LinkedList<Integer>> matrix;

        public Graph(int vertices) {
            this.vertices = vertices;
            this.matrix = new ArrayList<>();
            for(int i = 0; i <= vertices; i++) {
                this.matrix.add(new LinkedList<Integer>());
            }
        }

        public void addVertice(int u, int v) {
            this.matrix.get(u).add(v);
        }

        public void topologicalSortUtil(int start, boolean[] visited, Stack<Integer> vertices) {
            if(visited[start] != true) {
                for(int i : this.matrix.get(start)) {
                    topologicalSortUtil(i, visited, vertices);
                }
                visited[start] = true;
                vertices.push(start);
            }
        }

        public void topologicalSort() {
            Stack<Integer> vertices = new Stack<>();
            boolean[] visited = new boolean[this.matrix.size()];

            for(int i = 0; i < this.matrix.size(); i++) {
               topologicalSortUtil(i, visited, vertices);
            }

            while(!vertices.isEmpty()) {
                System.out.println(vertices.pop());
            }
        }

    }

    public static void main(String[] args) {
        Graph graph = new Graph(7);

        graph.addVertice(5, 2);
        graph.addVertice(5, 0);
        graph.addVertice(4, 0);
        graph.addVertice(4, 1);
        graph.addVertice(2, 3);
        graph.addVertice(3, 1);
    }
}

79. OOPs concepts of Aggregation and Composition

 - Aggregation implies a relationship where the child can exist independently of the parent. 
    Example: Class (parent) and Student (child). Delete the Class and the Students still exist.
 - Composition implies a relationship where the child cannot exist independent of the parent. 
    Example: House (parent) and Room (child). Rooms don't exist separate to a House.

80. Get max number of array in 1 swap

class java_rough {
    public static void main(String[] args) {
        int[] array = new int[]{9,9,8,4,5,6};

        int maxIndex, minIndex, currentMaxIndex, temp;

        maxIndex = array.length - 1;
        minIndex = array.length - 1;
        currentMaxIndex = array.length - 1;

        for(int i = array.length - 2; i >= 0 ;i--) {
            if(array[i] > array[currentMaxIndex]) {
                currentMaxIndex = i;
            } else if(array[currentMaxIndex] > array[i]) {
                maxIndex = currentMaxIndex;
                minIndex = i;
            }
        }
        temp = array[minIndex];
        array[minIndex] = array[maxIndex];
        array[maxIndex] = temp;
        
        for(int i : array) {
            System.out.println(i);
        }
    }
}

81. Time taken for all apples if Rotten apples are also in the rack 

import java.util.LinkedList;
import java.util.Queue;

class java_rough {
    public static void main(String[] args) {
        int[][] rack = new int[][]{
                     {0, 2, 0, 1, 2},
                     {0, 1, 1, 1, 1},
                     {1, 0, 0, 0, 1}
        };
        Queue<vertice> queue = new LinkedList<>();
        vertice temp;
        int counter = 0;

        for(int i = 0; i < rack.length; i++) {
            for(int j = 0; j < rack[0].length; j++) {
                if(rack[i][j] == 2) {
                    queue.add(new vertice(i, j));
                }
            }
        }
        queue.add(new vertice(-1, -1));
        
        while(!queue.isEmpty()) {
            temp = queue.poll();
            if(temp.x == -1 && temp.y == -1) {
                if(!queue.isEmpty()) {
                    queue.add(temp);
                    System.out.println("Added (-1, -1)");
                    counter++;
                }
            } else {
                queue = addAdjacent(rack, queue, temp);
            }
        }

        System.out.println(counter);
    }

    public static Queue<vertice> addAdjacent(int[][] rack, Queue<vertice> queue, vertice temp) {
        int x, y;

        x = temp.x;
        y = temp.y;

        if(isValid(x - 1, y - 1, rack.length, rack[0].length) && rack[x - 1][y - 1] == 1) {
            queue.add(new vertice(x - 1, y - 1));
            System.out.println("Added (" + (x - 1) + ", " + (y - 1) + ")");
            rack[x - 1][y - 1] = 2;
        }

        if(isValid(x - 1, y, rack.length, rack[0].length) && rack[x - 1][y] == 1) {
            queue.add(new vertice(x - 1, y));
            System.out.println("Added (" + (x - 1) + ", " + (y) + ")");
            rack[x - 1][y] = 2;
        }

        if(isValid(x - 1, y + 1, rack.length, rack[0].length) && rack[x - 1][y + 1] == 1) {
            queue.add(new vertice(x - 1, y + 1));
            System.out.println("Added (" + (x - 1) + ", " + (y + 1) + ")");
            rack[x - 1][y + 1] = 2;
        }

        if(isValid(x, y - 1, rack.length, rack[0].length) && rack[x][y - 1] == 1) {
            queue.add(new vertice(x, y - 1));
            System.out.println("Added (" + (x) + ", " + (y - 1) + ")");
            rack[x][y - 1] = 2;
        }

        if(isValid(x, y + 1, rack.length, rack[0].length) && rack[x][y + 1] == 1) {
            queue.add(new vertice(x, y + 1));
            System.out.println("Added (" + (x) + ", " + (y + 1) + ")");
            rack[x][y + 1] = 2;
        }

        if(isValid(x + 1, y - 1, rack.length, rack[0].length) && rack[x + 1][y - 1] == 1) {
            queue.add(new vertice(x + 1, y - 1));
            System.out.println("Added (" + (x + 1) + ", " + (y - 1) + ")");
            rack[x + 1][y - 1] = 2;
        }

        if(isValid(x + 1, y, rack.length, rack[0].length) && rack[x + 1][y] == 1) {
            queue.add(new vertice(x + 1, y));
            System.out.println("Added (" + (x + 1) + ", " + (y) + ")");
            rack[x + 1][y] = 2;
        }

        if(isValid(x + 1, y + 1, rack.length, rack[0].length) && rack[x + 1][y + 1] == 1) {
            queue.add(new vertice(x + 1, y + 1));
            System.out.println("Added (" + (x + 1) + ", " + (y + 1) + ")");
            rack[x + 1][y + 1] = 2;
        }

        return queue;
    }

    public static boolean isValid(int x, int y, int rows, int columns) {
        if(x >= 0 && x < rows && y >=0 && y < columns) {
            return true;
        } else {
            return false;
        }
    }

    static class vertice {
        int x;
        int y;

        vertice(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}

82. Prims Algorithm for Minimum Spanning Tree of a graph: Keep on selecting the minimum weight edge from any of the visited 
vertices till all vertices are covered.

 - Have a adjacencyMatrix having path weights between vertices
 - Add first vertex into visited set
 - Create priority queue with Comparator overridden to return smaller path 
 - Iterate over all connection for first vertex and add them to priority queue
 - Run a while loop till queue is empty or set size is equal to vertices
 - In  the loop check if the polled value from queue is already in visited set
 - If not add this vertex to visited set and iterate over all its connections to add to queue.


import java.util.Comparator;
import java.util.HashSet;
import java.util.PriorityQueue;

class java_rough {
    static class vertex {
        int path;
        int value;
        int parent;

        public vertex(int path, int value, int parent) {
            this.path = path;
            this.value = value;
            this.parent = parent;
        }
    }

    public static void main(String[] args) {
        int[][] adjacencyMatrix = new int[][]{
                        { 0, 12, 0, 1, 0 },  
                        { 12, 0, 3, 8, 5 },  
                        { 0, 3, 0, 0, 7 },  
                        { 1, 8, 0, 0, 9 },  
                        { 0, 5, 7, 9, 0 }
        };
        int total = 0;
        vertex temp;

        HashSet<Integer> visited = new HashSet<>();
        visited.add(0);

        PriorityQueue<vertex> queue = new PriorityQueue<>(new Comparator<vertex>() {
            @Override
            public int compare(vertex a, vertex b) {
                return a.path - b.path;
            }
        });

        for(int i = 0; i < adjacencyMatrix[0].length; i++) {
            if(adjacencyMatrix[0][i] != 0) {
                queue.add(new vertex(adjacencyMatrix[0][i], i, 0));
            }
        }

        while(!queue.isEmpty() && visited.size() != adjacencyMatrix.length) {
            temp = queue.poll();
            if(!visited.contains(temp.value)) {
                visited.add(temp.value);
                for(int i = 0; i < adjacencyMatrix[0].length; i++) {
                    if(adjacencyMatrix[temp.value][i] != 0) {
                        queue.add(new vertex(adjacencyMatrix[temp.value][i], i, temp.value));
                    }
                }
                total += temp.path;
                System.out.println(temp.parent + " -> " + temp.value);
            }
        }

        System.out.println("Total cost of MST = " + total);
    }
}

83. Shortest path between vertices

 - Have a adjacencyMatrix having path weights between vertices
 - Add first vertex into visited set
 - Create priority queue with Comparator overridden to return smaller path 
 - Iterate over all connection for first vertex and add them to priority queue
 - Run a while loop till queue is empty or set size is equal to vertices
 - In  the loop check if the polled value from queue is already in visited set
 - If not add this vertex to visited set and iterate over all its connections to add to queue.

import java.util.Comparator;
import java.util.HashSet;
import java.util.PriorityQueue;

class java_rough {
    static class vertex {
        int path;
        int value;
        int parent;

        public vertex(int path, int value, int parent) {
            this.path = path;
            this.value = value;
            this.parent = parent;
        }
    }

    public static void main(String[] args) {
        int[][] adjacencyMatrix = new int[][]{
            { 0, 4, 0, 0, 0, 0, 0, 8, 0 }, 
            { 4, 0, 8, 0, 0, 0, 0, 11, 0 }, 
            { 0, 8, 0, 7, 0, 4, 0, 0, 2 }, 
            { 0, 0, 7, 0, 9, 14, 0, 0, 0 }, 
            { 0, 0, 0, 9, 0, 10, 0, 0, 0 }, 
            { 0, 0, 4, 14, 10, 0, 2, 0, 0 }, 
            { 0, 0, 0, 0, 0, 2, 0, 1, 6 }, 
            { 8, 11, 0, 0, 0, 0, 1, 0, 7 }, 
            { 0, 0, 2, 0, 0, 0, 6, 7, 0 } 
        };
        int total = 0;
        vertex temp;

        HashSet<Integer> visited = new HashSet<>();
        visited.add(0);

        PriorityQueue<vertex> queue = new PriorityQueue<>(new Comparator<vertex>() {
            @Override
            public int compare(vertex a, vertex b) {
                return a.path - b.path;
            }
        });

        for(int i = 0; i < adjacencyMatrix[0].length; i++) {
            if(adjacencyMatrix[0][i] != 0) {
                queue.add(new vertex(adjacencyMatrix[0][i], i, 0));
            }
        }

        while(!queue.isEmpty() && visited.size() != adjacencyMatrix.length) {
            temp = queue.poll();
            if(!visited.contains(temp.value)) {
                visited.add(temp.value);
                for(int i = 0; i < adjacencyMatrix[0].length; i++) {
                    if(adjacencyMatrix[temp.value][i] != 0) {
                        queue.add(new vertex(adjacencyMatrix[temp.value][i] + temp.path, i, temp.value));
                    }
                }
                total += temp.path;
                System.out.println(temp.value + " -> " + temp.path);
            }
        }

        System.out.println("Total cost of MST = " + total);
    }
}

84. Adding 2 numbers formed from linked list

class java_rough {
    static class node {
        int value;
        node next;

        public node(int value, node next) {
            this.value = value;
            this.next = next;
        }

        public static node reverse(node root) {
            node next, prev, ptr;
            ptr = root;
            next = null;
            prev = null;

            while(ptr != null) {
                next = ptr.next;
                ptr.next = prev;
                prev = ptr;
                ptr = next;
            }
            return prev;
        }
    }

    public static void main(String[] args) {
        node n3 = new node(8, null);
        node n2 = new node(2, n3);
        node n1 = new node(1, n2);

        node m3 = new node(6, null);
        node m2 = new node(5, m3);
        node m1 = new node(9, m2);

        n1 = node.reverse(n1);
        m1 = node.reverse(m1);

        int carry = 0;
        int sum = 0;
        node start = n1;

        while(n1 != null && m1 != null) {
            sum = n1.value + m1.value + carry;
            carry = sum / 10;
            sum %= 10;
            n1.value = sum;
            n1 = n1.next;
            m1 = m1.next;
        }

        start = node.reverse(start);

        if(carry > 0) {
            System.out.print(carry);
        }

        while(start != null) {
            System.out.print(start.value);
            start = start.next;
        }
        
    }
}

85. Get last child who will receive toy when sitting circulalry

class java_rough {
    public static void main(String[] args) {
        int children = 5;
        int toys = 32;
        int start = 4;
        
        int r = toys % children;

        if(r == 0) {
            if(start == 1) {
                System.out.println(children);
            } else {
                System.out.println(start - 1);
            }
        } else {
            if((start + (r - 1)) % children == 0) {
                System.out.println(1);
            } else {
                System.out.println((start + (r - 1)) % children);
            }
            
        }
    }
}

86. Flattening linked list :-

class java_rough {
    static class Node {
        int data; 
        Node right, down; 
        Node(int data) 
        { 
            this.data = data; 
            right = null; 
            down = null; 
        }

        public static Node flattenLinkedList(Node root) {
          Node firstList, secondList;
          firstList = root;
          secondList = root.right;
          while(secondList != null) {
            firstList = mergeLinkedList(firstList, secondList);
            secondList = secondList.right;
          }
          return firstList;
        }

        public static Node mergeLinkedList(Node firstList, Node secondList) {
          Node resultList, resultNode;
          resultList = firstList;
          resultNode = resultList;
          firstList = firstList.down;
          while(firstList != null && secondList != null) {
            if(firstList.data < secondList.data) {
              resultNode.down = firstList;
              firstList = firstList.down;
            } else {
              resultNode.down = secondList;
              secondList = secondList.down;
            }
            resultNode = resultNode.down;
          }
          if(firstList != null) {
            resultNode.down = firstList;
          }
          if(secondList != null) {
            resultNode.down = secondList;
          }
          resultNode = resultNode.down;
          resultNode.down = null;
          return resultList;
        }
    }

    public static void main(String[] args) {
       Node n1 = new Node(5);
       Node n11 = new Node(7);
       Node n12 = new Node(8);
       Node n13 = new Node(30);

       Node n2 = new Node(10);
       Node n21 = new Node(20);

       Node n3 = new Node(19);
       Node n31 = new Node(22);
       Node n32 = new Node(50);

       n1.right = n2;
       n2.right = n3;
       
       n1.down = n11;
       n11.down = n12;
       n12.down = n13;

       n2.down = n21;

       n3.down = n31;
       n31.down = n32;

       Node start = Node.flattenLinkedList(n1);

       while(start != null) {
           System.out.println(start.data);
           start = start.down;
       }
    }
}

89. Finding if Directed graph has a cycle

  - Back edges, which point from a node to one of its ancestors
  - If there is a back edge ie graph has cycle
  - Back edge is when a vertex is visited again via a vertex that is not its parent

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Stack;

class java_rough {
    public static class Node {
        int value;
        int parent;

        public Node(int value) {
            this.value = value;
        }
    }
    public static class Graph {
        int vertices;
        ArrayList<LinkedList<Node>> matrix = new ArrayList<>();

        public Graph(int vertices) {
            this.vertices = vertices;
            for(int i = 0; i <= vertices; i++) {
                matrix.add(new LinkedList<Node>());
            }
        }

        public void addEdge(Node a, Node b) {
            this.matrix.get(a.value).add(b);
        }

        public void hasCycle(Node start, HashSet<Node> visited, HashSet<Integer> completed, int parent) {
            Node temp;
            if(!visited.contains(start)) {
                start.parent = parent;
                visited.add(start);
                while(!this.matrix.get(start.value).isEmpty()) {
                    temp = this.matrix.get(start.value).poll();
                    temp.parent = start.value;
                    hasCycle(temp, visited, completed, start.value);
                    completed.add(temp.value);
                }
            } else {
                if(!completed.contains(start.value)) {
                    System.out.println("We have a cycle with edge " + start.parent + " -> " + start.value);
                }
            }
        }
    }

    public static void main(String[] args) {
        Node node1 = new Node(1);
        Node node2 = new Node(2);
        Node node3 = new Node(3);
        Node node4 = new Node(4);

        Graph graph = new Graph(4);

        graph.addEdge(node2, node1);
        graph.addEdge(node3, node1);
        graph.addEdge(node1, node4);
        graph.addEdge(node4, node3);

        HashSet<Node> visited = new HashSet<>();
        HashSet<Integer> completed = new HashSet<>();

        graph.hasCycle(node2, visited, completed, 0);

    }
}

90. Writing a Java singleton class
    class java_rough {
        private static java_rough java_rough_instance = null;
        private java_rough() {
    }
        private static java_rough getInstance() {
            if(java_rough_instance == null) {
                java_rough_instance = new java_rough();
            }
            return java_rough_instance;
        }
}

EX : 
class java_rough {
    public static class demoSingleton {
        private static demoSingleton singleDemoSingletonObject = null;
        private static String msg;
        private demoSingleton() {}
        private demoSingleton(String msgReceived) {
            msg = msgReceived;
        }
        private static demoSingleton getDemoSingleton(String msgReceived) {
            if(singleDemoSingletonObject == null) {
                singleDemoSingletonObject = new demoSingleton(msgReceived);
            }
            return singleDemoSingletonObject;
        }
        public static String getMsg() {
            return demoSingleton.msg;
        }
    }

    public static String printMsg(String msgReceived) {
        demoSingleton.getDemoSingleton(msgReceived);
        return demoSingleton.getMsg();
    }
    public static void main(String[] args) {
        System.out.println(printMsg("first"));
        System.out.println(printMsg("second"));
    }
}

91. Finding Kth largest element using heapify

class java_rough {
    public static void main(String[] args) {
        int k = 4;
        int[] record = new int[]{3,5,2,0,1,7,6,5};
        for(int i = record.length / 2; i >= 0; i--) {
            heapify(record, i, record.length);
        }
        System.out.println("the " + k + "th largest value " + getKthSmallest(record, k));
    }
    
    public static void heapify(int[] record, int index, int size) {
        int largest, right, left;
        largest = index;
        right = 2 * index + 2;
        left = 2 * index + 1;

        if(left < size &&  record[largest] < record[left]) {
            largest = left;
        }

        if(right < size && record[largest] < record[right]) {
            largest = right;
        }

        if(largest != index) {
            swap(index, largest, record);
            heapify(record, largest, size);
        }
    }

    public static void swap(int index, int largest, int[] record) {
        int temp;
        temp = record[largest];
        record[largest] = record[index];
        record[index] = temp;
    }

    public static int getKthSmallest(int[] record, int k) {
        int length = record.length - 1;
        for(int i = 0; i < k - 1; i++) {
            swap(0, length, record);
            length--;
            heapify(record, 0, length + 1);
        }
        return record[0];
    }
}

92. Pythagorean Triplets

import java.util.Arrays;

class java_rough {
    public static void main(String[] args) {
        int[] record = new int[]{3, 10, 4, 8, 6, 5};
        Arrays.sort(record);
        int first, last;
        for(int i = record.length - 1; i > 1; i--) {
            first = 0;
            last = i - 1;
            while(first < last) {
                //System.out.println(first + ", " + last + ", " + i);
                if((Math.pow(record[first], 2) + Math.pow(record[last], 2)) == Math.pow(record[i], 2)) {
                    System.out.println(record[first] + ", " + record[last]);
                    first++;
                } else if ((Math.pow(record[first], 2) + Math.pow(record[last], 2)) < Math.pow(record[i], 2)) {
                    first++;
                } else {
                    last --;
                }
            }
        }
    }
}

92. Minimum differance when distributing chocolates among given students: https://www.geeksforgeeks.org/chocolate-distribution-problem/
import java.util.Arrays;
class java_rough {
    public static void main(String[] args) {
        int[] chocolatePacks = new int[]{12, 4, 7, 9, 2, 23, 25, 41, 30, 40, 28, 42, 30, 44, 48, 43, 50};
        int students = 7;
        int first, last, min;
        min = Integer.MAX_VALUE;
        first = 0;
        last = students - 1;
        Arrays.sort(chocolatePacks);
        while(last < chocolatePacks.length) {
            if(chocolatePacks[last] - chocolatePacks[first] < min) {
                min = chocolatePacks[last] - chocolatePacks[first];
            }
            first++;
            last++;
        }
        System.out.println("Min Diff is " + min);
    }
}

93. Stock Exchange problem: https://www.geeksforgeeks.org/stock-buy-sell/
class java_rough {
    public static void main(String[] args) {
        int[] prices = new int[]{100, 180, 260, 310, 40, 535, 695};
        int index = 0;
        int currentPrice = 0;
        int profit = 0;
        while(index < prices.length - 1) {
            if(prices[index] < prices[index + 1]) {
                if(currentPrice == 0) {
                    currentPrice = prices[index];
                }
            } else {
                if(currentPrice > 0) {
                    profit += (prices[index] - currentPrice);
                    currentPrice = 0;
                }
            }
            index ++;
        }
        if(prices[index] > currentPrice && currentPrice > 0) {
            profit += (prices[index] - currentPrice);
        }
        System.out.println(profit);
    }
}

94. Element with left side smaller and right side greater: https://www.geeksforgeeks.org/find-the-element-before-which-all-the-elements-are-smaller-than-it-and-after-which-all-are-greater-than-it/
class java_rough {
    public static void main(String[] args) {
        int[] record = new int[]{5, 1, 4, 3, 16, 8, 10, 17, 19};
        int[] leftMax = new int[record.length];
        int[] rightMin = new int[record.length];
        int max, min, length;
        length = record.length;
        max = 0;
        min = Integer.MAX_VALUE;
        for(int i = 0; i < length; i++) {
            leftMax[i] = max;
            if(max < record[i]) {
                max = record[i];
            }
            rightMin[length - 1 - i] = min;
            if(min > record[length - 1 - i]) {
                min = record[length - 1- i];
            }
        }
        for(int i = 0; i < length; i++) {
            if(leftMax[i] < record[i] && record[i] < rightMin[i]) {
                System.out.println("Left part < Right part for index: " + i);
            }
        }
    }
}

95. Converted array should be in form a < b > c < d > e < f: https://practice.geeksforgeeks.org/problems/convert-array-into-zig-zag-fashion/0
class java_rough {
    public static void main(String[] args) {
        //int[] record = new int[]{4, 3, 7, 8, 6, 2, 1};
        int[] record = new int[]{1, 4, 3, 2};
        int index = 1;
        while(index < record.length) {
            if(index == record.length - 1) {
                if(record[index - 1] > record[index]) {
                    swap(record, index, index - 1);
                }
            } else {
                if(record[index - 1] > record[index]) {
                    swap(record, index, index - 1);
                } 
                if(record[index + 1] > record[index]) {
                    swap(record, index, index + 1);
                }
            }
            index += 2;
        }
        for(int i : record) {
            System.out.println(i);
        }
    }
    public static void swap(int[] record, int index, int next) {
        int temp;
        temp = record[index];
        record[index] = record[next];
        record[next] = temp;
    }
}

96. Reversing order of words in string
import java.util.Stack;
class java_rough {
    public static void main(String[] args) {
        String input = "getting good at coding needs a lot of practice";
        Stack<Character> stack = new Stack<>();
        for(int i = input.length() - 1; i >=0; i--) {
            if(input.charAt(i) != ' ') {
                stack.push(input.charAt(i));
            } else {
                while(!stack.isEmpty()) {
                    System.out.print(stack.pop());
                }
                System.out.print(input.charAt(i));
            }
        }
        while(!stack.isEmpty()) {
            System.out.print(stack.pop());
        }
    }
}

97. Recursively remove all adjacent duplicates: https://www.geeksforgeeks.org/recursively-remove-adjacent-duplicates-given-string/
import java.util.Stack;
class java_rough {
    public static void main(String[] args) {
        String input = "caaabbbaacdddd";
        Stack<Character> stack = new Stack<>();
        int flag = 0;
        int i = 0;
        char temp;
        while(i < input.length()) {
            if(stack.isEmpty() || stack.peek() != input.charAt(i)) {
                if(flag == 1) {
                    temp = stack.pop();
                    System.out.println("popped: " + temp);
                    flag = 0;
                    continue;
                }
                stack.push(input.charAt(i));
                System.out.println("pushed: " + input.charAt(i));
            } else {
                if(i == input.length() - 1 ) {
                    stack.pop();
                }
                flag = 1;
            }
            i++;
        }
        printStack(stack);
    }
    public static void printStack(Stack<Character> stack) {
        if(stack.isEmpty()) {
            return;
        } else {
            char temp;
            temp = stack.pop();
            printStack(stack);
            System.out.print(temp);
        }
    }
}

98. Check if a string can be obtained by rotating another string 2 places: https://www.geeksforgeeks.org/check-string-can-obtained-rotating-another-string-2-places/
class java_rough {
    public static void main(String[] args) {
        String input = "amazon";
        int rotations = 2;
        String cw, acw, temp;
        temp = "";

        cw = input.substring(rotations);
        for(int i = 0; i < rotations; i++) {
            cw = cw + input.charAt(i);
        }
        System.out.println(cw);

        acw = input.substring(0, input.length() - rotations);
        for(int i = input.length() - rotations; i <= input.length() - 1; i++) {
            temp = temp + String.valueOf(input.charAt(i));
        }
        temp = temp + acw;
        System.out.println(temp);
    }
}

98. Form a palindrome by adding minimum number of alphabets: https://www.geeksforgeeks.org/minimum-insertions-to-form-a-palindrome-dp-28/

class java_rough {
    public static void main(String[] args) {
      String input = "abcde";
      int first, last;
      first = 0;
      last = input.length() - 1;
      System.out.println(getAdditionalCharacters(input, first, last));
    }
    public static int getAdditionalCharacters(String input, int first, int last) {
        if(first == last) {
            return 0;
        }
        if(first == (last - 1)) {
            return input.charAt(first) == input.charAt(last) ? 
                    0 : 1;
        }
        return input.charAt(first) == input.charAt(last) ? 
        getAdditionalCharacters(input, first + 1, last - 1) : 
        (Math.min(getAdditionalCharacters(input, first + 1, last), 
        getAdditionalCharacters(input, first, last - 1)) + 1);
    }
}

99. Longest common prefix in given strings: https://www.geeksforgeeks.org/longest-common-prefix-using-word-by-word-matching/

import java.util.Arrays;
class java_rough {
    public static void main(String[] args) {
      String[] input = new String[]{"gaeeksforgeeks", "geeks", "geek", "geezer"};
      Arrays.sort(input);
      int counter = 0;
      while(counter < input[0].length() && counter < input[input.length - 1].length()) {
          if(input[0].charAt(counter) != input[input.length - 1].charAt(counter)) {
            System.out.println(input[0].substring(0, counter));
            return;
          } else {
              counter++;
          }
      }
    }
}

100. Create a string from given String with only 2 alternating characters 

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

class java_rough {
    static HashSet<Character> getSameAdjacent(String sample) {
        HashSet<Character> dontInclude = new HashSet<>();
        for(int i = 0; i < sample.length() - 1; i++) {
            if(sample.charAt(i) == sample.charAt(i+1)) {
                dontInclude.add(sample.charAt(i));
                i++;
            }
        }
        return dontInclude;
    }

    static boolean sameAdjacent(String sample) {
        for(int i = 0; i < sample.length() - 1; i++) {
            if(sample.charAt(i) == sample.charAt(i+1)) {
               return false;
            }
        }
        return true;
    }

    static String createString(char a, char b, String sample) {
        List<Character> output = new ArrayList<>();
        for(int i = 0; i < sample.length(); i++) {
            if(sample.charAt(i) == a || sample.charAt(i) == b) {
                output.add(sample.charAt(i));
            }
        }

        StringBuilder outputString = new StringBuilder();
        for(Character c : output) {
            outputString.append(c);
        }
            if(sameAdjacent(String.valueOf(outputString))) {
                return String.valueOf(outputString);
            } else {
                return "";
            }
    }
    public static void main(String[] args) {
        String sample = "bbbbbaaaaa";
        int max = 0;
        String temp = "";
        String outPut = "";
        HashSet<Character> adjacentCharacters = getSameAdjacent(sample);
        List<Character>  nonAdjacentCharacter = new ArrayList<>();
        for(int i = 0; i < sample.length(); i++) {
            if(!adjacentCharacters.contains(sample.charAt(i))) {
                adjacentCharacters.add(sample.charAt(i));
                nonAdjacentCharacter.add(sample.charAt(i));
            }
        }
        for(int i = 0; i < nonAdjacentCharacter.size() - 1; i++) {
            for(int j = i + 1; j < nonAdjacentCharacter.size(); j++) {
                temp = createString(nonAdjacentCharacter.get(i), nonAdjacentCharacter.get(j), sample);
                if(max < temp.length()) {
                    max = temp.length();
                    outPut = temp;
                }

            }
        }

        System.out.println(outPut);

    }
}

101. Map implementation in Java:

import java.util.Scanner;

class java_rough {
    public static class Entry<K, V> {
        final K key;
        V value;
        Entry<K, V> next;

        public Entry(K key, V value, Entry<K, V> next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public static void main(String[] args) {
        int intialSize = 4;
        @SuppressWarnings("unchecked")
        Entry<String, String>[] map = new Entry[intialSize];
        Scanner scan = new Scanner(System.in);
        String key;
        String value;
        int tempIndex;
        Entry<String, String> dummyNodeEntry;
        for(int i = 0; i < intialSize; i++) {
            key = scan.nextLine();
            value = scan.nextLine();
            tempIndex = key.hashCode() % intialSize;
            System.out.println(key + ", " + value + ", " + tempIndex);
            if(map[tempIndex] == null) {
                map[tempIndex] = new Entry<String, String>(key, value, null);
            } else if(map[tempIndex].key.equals(key)) {
                System.out.println("key Alredy exists");
            } else {
                map[tempIndex].next = new Entry<String, String>(key, value, null);
            }
        }

        System.out.println("Retrieval begins");

        for(int i = 0; i < intialSize; i++) {
            key = scan.nextLine();
            tempIndex = key.hashCode() % intialSize;
            if(map[tempIndex].key.equals(key)) {
                System.out.println("for " + key + " value is " + map[tempIndex].value);
            } else {
                dummyNodeEntry = map[tempIndex].next;
                while(dummyNodeEntry != null) {
                    System.out.println("dummyNode " + dummyNodeEntry.key + ", " + dummyNodeEntry.value);
                    if(dummyNodeEntry.key.equals(key)) {
                        System.out.println(map[tempIndex].value);
                        break;
                    } else {
                        dummyNodeEntry = dummyNodeEntry.next;
                    }
                }
            }
        }
        scan.close();
    }
}

102. Common REGEX patterns: https://mkyong.com/regular-expressions/10-java-regular-expression-examples-you-should-know/
-   Username:   ^[a-z0-9_-]{3,15}$

                ^                    # Start of the line
                [a-z0-9_-]	     # Match characters and symbols in the list, a-z, 0-9 , underscore , hyphen
                            {3,15}  # Length at least 3 characters and maximum length of 15 
                $                    # End of the line

-   Password:   ((?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%]).{6,20})

                (			# Start of group
                (?=.*\d)		#   must contains one digit from 0-9
                (?=.*[a-z])		#   must contains one lowercase characters
                (?=.*[A-Z])		#   must contains one uppercase characters
                (?=.*[@#$%])		#   must contains one special symbols in the list "@#$%"
                            .		#     match anything with previous condition checking
                                {6,20}	#        length at least 6 characters and maximum of 20	
                )	
EX:     import java.util.regex.Pattern;

        class java_rough {
            public static void main(String[] args) {
                String pattern = "((?=(.*\\d){2})(?=.*[a-z])(?=.*[A-Z]).{3,8})";
                Pattern tester = Pattern.compile(pattern);
                System.out.println(tester.matcher("1pLLut").matches());
            }
        }

-   Email:  ^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9]+ (\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$

                    ^			#start of the line
                    [_A-Za-z0-9-]+	#  must start with string in the bracket [ ], must contains one or more (+)
                    (			#  start of group #1
                        \\.[_A-Za-z0-9-]+	#     follow by a dot "." and string in the bracket [ ], must contains one or more (+)
                    )*			#  end of group #1, this group is optional (*)
                        @			#     must contains a "@" symbol
                        [A-Za-z0-9]+       #        follow by string in the bracket [ ], must contains one or more (+)
                        (			#	   start of group #2 - first level TLD checking
                        \\.[A-Za-z0-9]+  #	     follow by a dot "." and string in the bracket [ ], must contains one or more (+)
                        )*		#	   end of group #2, this group is optional (*)
                        (			#	   start of group #3 - second level TLD checking
                        \\.[A-Za-z]{2,}  #	     follow by a dot "." and string in the bracket [ ], with minimum length of 2
                        )			#	   end of group #3
                    $			#end of the line

-   Image:  ([^\s]+(\.(?i)(jpg|png|gif|bmp))$)

            (			#Start of the group #1
            [^\s]+			#  must contains one or more anything (except white space)
                (		#    start of the group #2
                    \.		#	follow by a dot "."
                    (?i)		#	ignore the case sensitive checking
                        (		#	  start of the group #3
                        jpg	#	    contains characters "jpg"
                        |		#	    ..or
                        png	#	    contains characters "png"
                        |		#	    ..or
                        gif	#	    contains characters "gif"
                        |		#	    ..or
                        bmp	#	    contains characters "bmp"
                        )		#	  end of the group #3
                )		#     end of the group #2	
            $			#  end of the string
            )		


103. Matrix chain multiplication recursive solution

class java_rough {
    
    public static int matrixMultiplication(int[] matrixDimensions, int firstMatrix, int lastMatrix) {
        if(firstMatrix == (lastMatrix - 2)) {
            return (matrixDimensions[firstMatrix] * matrixDimensions[firstMatrix + 1] * matrixDimensions[lastMatrix]);
        } else if (firstMatrix > (lastMatrix - 2)) {
            return 0;
        }
        int count = 0;
        int numberOfMultiplicationsRequired = Integer.MAX_VALUE;
        for(int middleMatrix = firstMatrix + 1; middleMatrix < lastMatrix; middleMatrix++) {
            count = matrixMultiplication(matrixDimensions, firstMatrix, middleMatrix) + 
                    matrixMultiplication(matrixDimensions, middleMatrix, lastMatrix) + 
                    matrixDimensions[firstMatrix]*matrixDimensions[lastMatrix]*matrixDimensions[middleMatrix];

            System.out.println(count);
            numberOfMultiplicationsRequired = Math.min(numberOfMultiplicationsRequired, count);
        }
        return numberOfMultiplicationsRequired;
    }
    
    public static void main(String[] args) {
        int[] matrixDimensions = new int[]{40, 20, 30, 10, 30};
        //int[] matrixDimensions = new int[]{4, 3, 4, 5};
        int firstMatrix, lastMatrix;
        firstMatrix = 0;
        lastMatrix = matrixDimensions.length - 1;
        System.out.println("minimum multiplications required: " + matrixMultiplication( matrixDimensions, 
                                                                                        firstMatrix, 
                                                                                        lastMatrix));
    }
}

104. Assembly Line Scheduling 

class java_rough {

    public static int carAssembly(int[][] station, int[][] transfer, int[] entry, int[] exit) {
        int stationsPresent = station[0].length;
        int[] beltA = new int[stationsPresent];
        int[] beltB = new int[stationsPresent];
        
        beltA[0] = station[0][0] + entry[0];
        beltB[0] = station[1][0] + entry[1];
        int counter = 1;
        while(counter < stationsPresent) {
            beltA[counter] = Math.min(beltA[counter - 1] + station[0][counter], 
                                        beltB[counter - 1] + transfer[1][counter] + station[0][counter]);
                                        
            beltB[counter] = Math.min(beltB[counter - 1] + station[1][counter], 
                                        beltA[counter - 1] + transfer[0][counter] + station[1][counter]);

            counter ++;
        }
        return Math.min(beltA[counter - 1] + exit[0], beltB[counter - 1] + exit[1]);
    }
    public static void main(String[] args) {
        int station[][] = {{4, 5, 3, 2}, 
                    {2, 10, 1, 4}}; 
        int transfer[][] = {{0, 7, 4, 5}, 
                    {0, 9, 2, 8}}; 
        int entry[] = {10, 12};
        int exit[] = {18, 7}; 
      
        System.out.println(carAssembly(station , transfer, entry, exit));
    }
}

105. Finding only number repeated odd times

class java_rough {
    public static void main(String[] args) {
        int[] arrays = new int[]{2,6,4,3,3,6,2};
        int xoredResult = 0;
        for(int i : arrays) {
            xoredResult = i^xoredResult;
        }
        System.out.println(xoredResult);
    }
}

106. Sorting array with only 3 values in O(n)

class java_rough {
    
    public static void swap(int[] array, int first, int second) {
        if(first == second) {
            return;
        } else {
            int temp;
            temp = array[first];
            array[first] = array[second];
            array[second] = temp;
        }
    }
    
    public static void main(String[] args) {
        int[] only3Values = new int[]{2,1,1,0,2,1,2,0,0,2,0};
        int first, current, last;
        first = 0;
        last = only3Values.length - 1;
        current = 0;
        while(current <= last) {
            switch(only3Values[current]) {
                case 0:
                    swap(only3Values, first, current);
                    first++;
                    current++;
                    break;

                case 1:
                    current++;
                    break;

                case 2: 
                    swap(only3Values, last, current);
                    last--;
                    break;
            }
        }

        for(int i : only3Values) {
            System.out.print(i + ", ");
        }
    }
}

107. Power of number in log(power)

class java_rough {
    public static void main(String[] args) {
        int number = 5;
        int power = 10;

        System.out.println(powerCalculate(number, power));
    }

    public static int powerCalculate(int number, int power) {
        if(power == 1) {
            return number;
        } else if(power %2 == 0) {
            return powerCalculate(number, power/2) * powerCalculate(number, power/2);
        } else {
            return number *powerCalculate(number, power - 1);
        }
    }
}

108. Finding prime number less than equal to upper limit: sieve-of-eratosthenes

class java_rough {
    public static void main(String[] args) {
        int upperLimit = 53;
        int[] recordPrimeNumbers = new int[upperLimit + 1];
        int start;
        for(int i = 2; i <= upperLimit; i++) {
            if(recordPrimeNumbers[i] == 0) {
                start = i;
                for(int j = i*i; j <= upperLimit; j = i * start) {
                    recordPrimeNumbers[j] = -1;
                    start++;
                }
            }
        }
        for(int i = 2; i <= upperLimit; i++) {
            if(recordPrimeNumbers[i] == 0) {
                System.out.print(i + ", ");
            }
        }
    }
}

109. Given an array of integer numbers, we need to find maximum size of a subset such that sum of each pair of this 
     subset is not divisible by K.

class java_rough {
    public static void main(String[] args) {
        int[] numbers = new int[]{3, 17, 12, 9, 11, 15};
        int divisor = 5;
        int[] remainders = new int[divisor];
        int result = 0;

        for(int i = 0; i < numbers.length; i++) {
            remainders[numbers[i] % divisor]++;
        }

        if(divisor % 2 == 0) {
            remainders[divisor/2] = Math.min(1, remainders[divisor/2]);
        }

        result = Math.min(1, remainders[0]);

        for(int i = 1; i <= divisor/2; i++) {
            result = result + Math.max(remainders[i], remainders[divisor - i]);
        }

        System.out.println(result);

    }
}

110. Tower of hanoi

class java_rough {

    public static void towerOfHanoi(int disks, char from, char to, char aux) {
        if(disks == 1) {
            System.out.println ("move from " + disks + ", " + from + " to " + to);
            return;
        }
        towerOfHanoi(disks - 1, from, aux, to);
        System.out.println ("move from " + disks + ", " + from + " to " + to);
        towerOfHanoi(disks - 1, aux, to, from);
    }
    public static void main(String[] args) {
    int disks = 3;
    towerOfHanoi(disks, 'A', 'C','B');
    }
}

111. Seprate numbers given if they are consecutive

static void separateNumbers(String s) {
        long temp;
        String result;
        for(int i = 1; i <= s.length()/2; i++) {
            result = s.substring(0, i);
            temp = Long.parseLong(result);
            while(result.length() < s.length()) {
                temp++;
                result = result + String.valueOf(temp);
            }
            if(result.equals(s)) {
                System.out.println("YES " + s.substring(0, i));
                return;
            }
        }
        System.out.println("NO");
    }

112. Finding max number possible from swapping upto k times in given array

static int[] largestPermutation(int k, int[] arr) {
        int swaps = 0;
        int index = 0;
        int tempIndex = 0;
        int temp;
        int[] tempArray = new int[arr.length];
        for(int i = 0; i < arr.length; i++) {
            tempArray[i] = arr[i];
        }
        Arrays.sort(tempArray);
        while(swaps < k && index < arr.length) {
            if(tempArray[arr.length - 1 - index] != arr[index]) {
                for(int i = index + 1; i < arr.length; i++) {
                    if(arr[i] == tempArray[arr.length - 1 - index]) {
                        tempIndex = i;
                        break;
                    }
                }
                temp = arr[tempIndex];
                arr[tempIndex] = arr[index];
                arr[index] = temp;
                swaps++;
            }
            index++;
        }
        return arr;
    }


113. Finding number of islands present in given grid:

class java_rough {

    public static int[][] bfs(int[][] locations, int i, int j) {
        if(i < 0 || i >= locations.length || j < 0 || j >= locations[i].length || locations[i][j] == 0) {
            return locations;
        }
        locations[i][j] = 0;
        bfs(locations, i + 1, j);
        bfs(locations, i - 1, j);
        bfs(locations, i, j + 1);
        bfs(locations, i, j - 1);

        return locations;
    }
    public static void main(String[] args) {
        int[][] locations = new int[][]{{1,1,0,0,0},
                                        {1,1,0,0,0},
                                        {0,0,1,0,0},
                                        {0,0,0,1,1}};

        int islands = 0;

        for(int i = 0; i < locations.length; i++) {
            for(int j = 0; j < locations[i].length; j++) {
                if(locations[i][j] == 1) {
                    islands++;
                    locations = bfs(locations, i, j);
                }
            }
        }
        System.out.println(islands);
    }
}

114. Pascals triangle

class java_rough {
    public static void main(String[] args) {
        int rows = 5;
        int[][] pascals = new int[rows][rows]
;        for(int i = 0; i < rows; i++) {
            for(int j = 0; j <= i; j++) {
                if(j == 0 || j == i) {
                    pascals[i][j] = 1;
                } else {
                    pascals[i][j] = pascals[i - 1][j - 1] + pascals[i  -1][j];
                }
            }
        }
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j <= i; j++) {
                System.out.print(pascals[i][j]);
            }
            System.out.println();
        }
    }
}

115. Merge two Binary trees:

import java.util.LinkedList;
import java.util.Queue;

class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public static void lot(node root) {
            Queue<node> queue = new LinkedList<>();
            queue.add(root);
            node temp;
                while(!queue.isEmpty()) {
                    temp = queue.poll();
                    System.out.print(temp.value + ", ");
                    if(temp.lc != null) {
                        queue.add(temp.lc);
                    }

                    if(temp.rc != null) {
                        queue.add(temp.rc);
                    }
                }
                System.out.println("lot traversal");
        }

        public static node merged(node root, node root1) {
            node result = null;
            if(root == null && root1 == null) {
                return result;
            } else if(root != null && root1 != null) {
                result = new node(root.value + root1.value);
                result.lc = merged(root.lc, root1.lc);
                result.rc = merged(root.rc, root1.rc);
            } else if(root != null) {
                result = new node(root.value);
                result.lc = merged(root.lc, null);
                result.rc = merged(root.rc, null);
            } else {
                result = new node(root1.value);
                result.lc = merged(root1.lc, null);
                result.rc = merged(root1.rc, null);
            } //8, 1, 7, 1, 2, 6, 8, 2, 8, 10, 9, 12,
            return result;
        }
    }
    public static void main(String[] args) {
        node root = new node(3);
        root.insert(root, 1);
        root.insert(root, 7);
        root.insert(root, 2);
        root.insert(root, 6);
        root.insert(root, 8);

        node root1 = new node(5);
        root.insert(root1, 2);
        root.insert(root1, 10);
        root.insert(root1, 1);
        root.insert(root1, 8);
        root.insert(root1, 12);
        root.insert(root1, 9);

        node.lot(node.merged(root, root1));
    }
}

116. Create a mirror image of given tree

import java.util.LinkedList;
import java.util.Queue;

class java_rough {
    static class node {
        public int value;
        public node lc;
        public node rc;

        public node(int value) {
            this.value = value;
            this.lc = null;
            this.rc = null;
        }

        public node insert(node root, int value) {
            if(root == null) {
                //System.out.println(value);
                root = new node(value);
            } else {
                if(value > root.value) {
                    //System.out.println("rc");
                    root.rc = insert(root.rc, value);
                } else {
                    //System.out.println("lc");
                    root.lc = insert(root.lc, value);
                }
            }
            return root;
        }

        public static void lot(node root) {
            Queue<node> queue = new LinkedList<>();
            queue.add(root);
            node temp;
                while(!queue.isEmpty()) {
                    temp = queue.poll();
                    System.out.print(temp.value + ", ");
                    if(temp.lc != null) {
                        queue.add(temp.lc);
                    }

                    if(temp.rc != null) {
                        queue.add(temp.rc);
                    }
                }
                System.out.println("lot traversal");
        }

        public static node swap(node root) {
            if(root == null) {
                return root;
            } else {
                node temp;
                temp = root.lc;
                root.lc = root.rc;
                root.rc = temp;
                swap(root.lc);
                swap(root.rc);
            }
            return root;
        }
    }
    public static void main(String[] args) {
        node root = new node(3);
        root.insert(root, 1);
        root.insert(root, 7);
        root.insert(root, 2);
        root.insert(root, 6);
        root.insert(root, 8);

        node.lot(node.swap(root));
    }
}

117. Arranging given LL such that elements at odd position are at beginning followed by even positioned values

class java_rough {
    static class node {
        int value;
        node next;

        void setValue(int value) {
            this.value = value;
        }
        void setNode(node next) {
            this.next = next;
        }

        int getValue() {
            return this.value;
        }

        node getNode() {
            return this.next;
        }

        public static node oddEven(node root) {
            node even = root.next;
            node evenHead = even;
            node odd = root;
            int counter = 0;

            while(even != null && even.next != null) {
                odd.next = even.next;
                odd = odd.next;
                even.next = odd.next;
                even = even.next;
                System.out.println(counter++);
            }
            System.out.println(odd.value + ", " + evenHead.value);
            odd.next = evenHead;
            return root;
        }
    }

    public static void main(String[] args) {
        node n1 = new node();
        node n2 = new node();
        node n3 = new node();
        node n4 = new node();
        node n5 = new node();
        node n6 = new node();

        n1.setValue(1);
        n2.setValue(2);
        n3.setValue(3);
        n4.setValue(4);
        n5.setValue(5);
        n6.setValue(6);

        n1.setNode(n2);
        n2.setNode(n3);
        n3.setNode(n4);
        n4.setNode(n5);
        n5.setNode(n6);
        n6.setNode(null);
        
        node temp = node.oddEven(n1);
        while(temp != null) {
            System.out.println(temp.getValue());
            temp = temp.getNode();
        }
    }
}


118. Comparing Strings after computing the value considering # is backspace operation

import java.util.Stack;

class java_rough {

    public static String getActualString(String string) {
        Stack<Character> stack = new Stack<>();
        for(int i = 0; i < string.length(); i++) {
            if(string.charAt(i) == '#') {
                if(!stack.isEmpty())
                    stack.pop();
            } else {
                stack.push(string.charAt(i));
            }
        }
        return String.valueOf(stack);
    }
    public static void main(String[] args) {
        String first = "a##c";
        String second = "#a#c";

        first = getActualString(first);
        second = getActualString(second);

        System.out.println(first + ", " + second);

        System.out.println(first.equals(second));
    }
}

119. Rooms that can be opened if keys are present in other rooms
//input: [[1],[2],[3],[]]
//outout: true
class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        HashSet<Integer> keys = new HashSet<>();
        Queue<Integer> visited = new LinkedList<>();
        keys.add(0);
        visited.add(0);
        int i;
        int count = 0;
        while(!visited.isEmpty()) {
            i = visited.poll();
            if(keys.contains(i)) {
                for(int j : rooms.get(i)) {
                    if(!keys.contains(j)) {
                        keys.add(j);
                        visited.add(j);
                    }
                }
                count++;
            }
        }
        if(count == rooms.size()) {
            return true;
        } else {
            return false;
        }
    }
}

120. Sorted array being sorted after every value is squared : https://leetcode.com/problems/squares-of-a-sorted-array/

class java_rough {
    public static void main(String[] args) {
        int[] numbers = new int[]{-6, -4, 0, 2, 5, 7};
         int i = 0;
         while(numbers[i] < 0) {
             i++;
         }
         int positive = i;
         for(i = 0; i < numbers.length; i++) {
             numbers[i] = (int)Math.pow(numbers[i], 2);
         }
         if(positive == 0) {
            for(int num : numbers) {
                System.out.println(num);
            }
         } else {
            int negative = positive - 1;
            while(negative >= 0 && positive < numbers.length) {
                if(numbers[positive] < numbers[negative]) {
                    System.out.println(numbers[positive]);
                    positive++;
                } else {
                    System.out.println(numbers[negative]);
                    negative--;
                }
            }
            if(negative >= 0) {
                while(negative >= 0) {
                    System.out.println(numbers[negative]);
                    negative--;
                }
            } else {
                while(positive < numbers.length) {
                    System.out.println(numbers[positive]);
                    positive++;
                }
            }
        }
    }
}

121. Selecting two walls that will store the max capacity of Water : https://leetcode.com/problems/container-with-most-water/

class java_rough {
    public static void main(String[] args) {
        int[] heights = new int[]{1,8,6,2,5,4,8,3,7};
        int capacity, leftIndex, rightIndex, volume;
        leftIndex = 0;
        rightIndex = heights.length - 1;
        capacity = 0;
        volume = 0;

        while(leftIndex <= rightIndex) {
            volume = heights[leftIndex] < heights[rightIndex] ? heights[leftIndex] : heights[rightIndex];
            volume *= (rightIndex - leftIndex);
            if(capacity < volume) {
                capacity = volume;
            }
            if(heights[rightIndex] < heights[leftIndex]) {
                rightIndex--;
            } else {
                leftIndex++;
            }
        }
        System.out.println(capacity);
    }
}

122. Adding 3 numbers from Array to get equal or closest to target value

import java.util.Arrays;

class java_rough {
    public static void main(String[] args) {
        int[] nums = new int[]{-1, 2, 1, -4};
        int first, last, result, target, current;
        result = nums[0] + nums[1] + nums[nums.length  -1];
        target = 1;
        Arrays.sort(nums);
        for(int i = 0; i < nums.length - 1; i++) {
            first = i + 1;
            last = nums.length - 1;
            while(first < last) {
                current = nums[i] + nums[first] + nums[last];
                if(current == target) {
                    System.out.println(current);
                    return;
                } else {
                    if(current < target) {
                        first++;
                    } else {
                        last--;
                    }
                }
                if(Math.abs(target - current) < Math.abs(target - result)) {
                    result = current;
                }
            }
        }
        System.out.println(result);
    }
}

123. Finding number repeated in an array multiple times knowing that all number are between 1 and size of array

class java_rough {
    public static void main(String[] args) {
        int[] nums = new int[]{3,1,3,4,2};
        int counter = 0;
        int fast, slow;
        slow = nums[0];
        fast = nums[0];
        slow = nums[slow];
        fast = nums[nums[fast]];
        while(slow != fast) {
            System.out.println(slow + ", " + fast);
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        System.out.println(slow);
        slow = nums[0];
        while(slow != fast && counter < 7) {
            System.out.println(slow + ", " + fast);
            slow = nums[slow];
            fast = nums[fast];
            counter++;
        }
        System.out.println(fast);
    }
}

124. Removing subtree from binary tree of 0 and 1 that do not contain any 1

class Solution {
    public boolean containsOne(TreeNode root) {
        if(root == null) {
            return false;
        } else {
            boolean rightOne, leftOne;
            rightOne = containsOne(root.right);
            leftOne = containsOne(root.left);
            if(!rightOne) {
                root.right = null;
            }
            if(!leftOne) {
                root.left = null;
            }
            return (root.val == 1 || rightOne || leftOne);
        }
    }
    public TreeNode pruneTree(TreeNode root) {
        containsOne(root);
        return root;
    }
}

125. Finding if given cards are consecutive hands given cards and size of hand to be formed

import java.util.Arrays;
import java.util.TreeMap;
import java.util.ArrayList;

class java_rough {
    public static void main(String[] args) {
        int[] cards = new int[]{1,2,3,6,3,4,7,8};
        Arrays.sort(cards);
        int hand = 3;
        TreeMap<Integer, Integer> record = new TreeMap<>();
        for(int i : cards) {
            if(record.containsKey(i)) {
                record.put(i, record.get(i)+1);
            } else {
                record.put(i, 1);
            }
        }
        int index = 0;
        int count = 1;
        int temp;
        while(index < cards.length) {
            temp = cards[index];
            if(record.get(temp) > 0) {
                record.put(temp, record.get(temp) - 1);
                while(count < hand) {
                    temp++;
                    if(record.containsKey(temp) && record.get(temp) > 0) {
                        record.put(temp, record.get(temp) - 1);
                    } else {
                        System.out.println(false);
                        return;
                    }
                    count++;
                }
            }
            count = 1;
            index++;
        }
        System.out.println(true);
    }
}

126. Arranging LinkedList according to values relative to given target value with values smaller and larger at different sides : https://leetcode.com/problems/partition-list/

class java_rough {
    static class node {
        int val;
        node next;

        void setValue(int value) {
            this.val = value;
        }
        void setNode(node next) {
            this.next = next;
        }

        int getValue() {
            return this.val;
        }

        node getNode() {
            return this.next;
        }

        public static node arrange(node root, int target) {
            node smaller, larger, nextNode, current, largerPointer, smallerPointer;
            smaller = null;
            larger = null;
            smallerPointer = null;
            largerPointer = null;
            current = root;
            int counter = 0;
            while(current != null) {
                nextNode = current.next;
                if(current.val < target) {
                    if(smaller == null) {
                        smaller = current;
                        smallerPointer = smaller;
                        System.out.println("smaller start " + smaller.val);
                    } else {
                        smaller.next = current;
                        smaller = smaller.next;
                        System.out.println("Added smaller " + smaller.val);
                    }
                } else {
                    if(larger == null) {
                        larger = current;
                        largerPointer = larger;
                        System.out.println("larger start " + larger.val);
                    } else {
                        larger.next = current;
                        larger = larger.next;
                        System.out.println("Added larger " + larger.val);
                    }
                }
                current = nextNode;
            }
            if(larger != null) {
                larger.next = null;   
            }
            if(smaller != null) {
                smaller.next = largerPointer;
            } else {
                smaller = largerPointer;
                return smaller;
            }
            return smallerPointer;
        }
    }


    public static void main(String[] args) {
        node n1 = new node();
        node n2 = new node();
        node n3 = new node();
        node m1 = new node();
        node m2 = new node();
        node m3 = new node();

        n1.setValue(1);
        n1.setNode(n2);

        n2.setValue(4);
        n2.setNode(n3);
        
        n3.setValue(3);
        n3.setNode(m1);

        m1.setValue(2);
        m1.setNode(m2);

        m2.setValue(5);
        m2.setNode(m3);
        
        m3.setValue(2);
        m3.setNode(null);
        node temp;
        temp = node.arrange(n1, 3);;
        while(temp != null) {
            System.out.println(temp.val);
            temp = temp.next;
        }
    }
}

127. Checking if a tree is complete binary tree or not
import java.util.LinkedList;
import java.util.Queue;

class java_rough {
    public boolean isCompleteTree(TreeNode root) {
        if(root == null) {
            return true;
        }
        Queue<TreeNode> lot = new LinkedList<>();
        boolean nullVisited = false;
        lot.add(root);
        TreeNode temp;
        while(!lot.isEmpty()) {
           temp = lot.poll();
           if(temp == null) {
               nullVisited = true;
           } else {
               if(nullVisited) {
                   return false;
               } else {
                   lot.add(temp.left);
                   lot.add(temp.right);
               }
           }
        }
        return true;
    }
}

128. Flatenning a tree and representing it as LinkedList in place with all elements as right child of each other : https://leetcode.com/problems/flatten-binary-tree-to-linked-list/submissions/
// Use Stack for inorder traversal
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

class java_rough {
    public void isCompleteTree(TreeNode root) {
        if(root == null) {
            return;
        }
        Stack<TreeNode> record = new Stack<>();
        TreeNode temp;
        record.push(root);
        
        while(!record.isEmpty()) {
            temp = record.pop();
            if(temp.right != null) {
                record.push(temp.right);
            }

            if(temp.left != null) {
                record.push(temp.left);
            }

            if(!record.isEmpty()) {
                temp.right = record.peek();
            }
            temp.left = null;
        }
    }
}

129. Finding sum of all left leaf node in a tree : https://leetcode.com/problems/sum-of-left-leaves/submissions/

class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
       int sum = 0;
       int nodePosition = 1;
       TreeNode temp;
       Queue<TreeNode> lot = new LinkedList<>();
       lot.add(root);
       while(!lot.isEmpty()) {
           temp = lot.poll();
           if(temp == null) { 
               continue; 
            } else if(temp.left == null && temp.right == null && nodePosition % 2 == 0) {
               sum += temp.val;
           } else {
               lot.add(temp.left);
               lot.add(temp.right);
           }
           nodePosition ++;
       }
       return sum;
    }

130. Reversing only character position in String not of special characters

import java.util.HashSet;

class  java_rough{
    public static void main(String[] args) {
        String inputString = "a-bC-dEf-ghIj";
        char[] result = new char[inputString.length()];
        char[] inputArray = inputString.toCharArray();
        int i, j, temp;
        HashSet<Integer> specialCharacters = new HashSet<>();
        for(i = 0; i < result.length; i++) {
            temp = (int) inputArray[i];
            if(!((temp >= 65 && temp <= 90) || (temp >= 97 && temp <= 122))) {
                result[i] = inputArray[i];
                specialCharacters.add(i);
            }
        }
        i = inputArray.length - 1;
        j = 0;
        while(i >= 0 && j < inputArray.length) {
            if(specialCharacters.contains(j)) {
                j++;
            } else {
                temp = (int) inputArray[i];
                if(specialCharacters.contains(i)) {
                    i--;
                } 
                else {
                    result[j] = inputArray[i];
                    j++;
                    i--;
                }
            }
        }
        System.out.println(String.valueOf(result));
    }
}

131. Checking if number is divisible by all digits present in number : https://leetcode.com/problems/self-dividing-numbers/submissions/

class Solution {
    public List<Integer> selfDividingNumbers(int left, int right) {
        ArrayList<Integer> numbers = new ArrayList<>();
        for(int i = left; i <= right; i++) {
            if(selfDivisible(i)) {
                System.out.println(i);
                numbers.add(i);
            }   
        }
        return numbers;
    }
    
    public boolean selfDivisible(int number) {
        int temp;
        int zero = (int) '0';
        for(char c : String.valueOf(number).toCharArray()) {
            temp = (int) c;
            temp -= zero;
            if(temp == 0 || number % temp != 0) {
                return false;
            }
        }
        return true;
    }
}

132. Getting all common alphabet including duplicates from given strings : https://leetcode.com/problems/find-common-characters/submissions/

class Solution {
    public List<String> commonChars(String[] A) {
            int[] frequency = new int[26];
            Arrays.fill(frequency, Integer.MAX_VALUE);
            int temp;
            for(String inputString : A) {
                int[] current = new int[26];
                for(int i = 0; i < inputString.length(); i++) {
                    temp = (int) inputString.charAt(i);
                    temp -= 97;
                    current[temp]++;
                }
                for(int i = 0; i < 26; i++) {
                    frequency[i] = Math.min(frequency[i], current[i]);
                }
            }
        
            List<String> result = new ArrayList<>();
            for(int i = 0; i < 26; i++) {
                if(frequency[i] > 0) {
                    while(frequency[i] > 0) {
                        result.add("" + (char)(i + 97));
                        frequency[i]--;
                    }
                }
            }
        return result;
        }
}

135. Executing operations and returning sum of all even values after each operation : https://leetcode.com/problems/sum-of-even-numbers-after-queries/submissions/

 public int[] sumEvenAfterQueries(int[] inputArray, int[][] queries) {
            int sum = 0;
            int index, currentValue;
            int[] result = new int[queries.length];
            for(int i = 0; i < inputArray.length; i++) {
                if(inputArray[i] % 2 == 0) {
                    sum += inputArray[i];
                }
            }
            for(int i = 0; i < queries.length; i++) {
                index = queries[i][1];
                System.out.print(sum);
                currentValue = queries[i][0];
                if(inputArray[index] % 2 == 0) {
                    sum -= inputArray[index];
                }
                inputArray[index] += currentValue;
                if(inputArray[index] % 2 == 0) {
                    sum += inputArray[index];
                }
                result[i] = sum;
            }
            return result;
        }

136. Sort array such that even indexes have even value and odd indexes have odd values : https://leetcode.com/problems/sort-array-by-parity-ii/submissions/

    public int[] sortArrayByParityII(int[] arrayNumbers) {
        int even, odd, temp;
        even = 0;
        odd = 1;
        while(even < arrayNumbers.length && odd < arrayNumbers.length) {
            while(even < arrayNumbers.length && arrayNumbers[even] % 2 == 0) {
                even += 2;
            }
            while(odd < arrayNumbers.length && arrayNumbers[odd] % 2 == 1) {
                odd += 2;
            }

            if(even < arrayNumbers.length && odd < arrayNumbers.length) {
                temp = arrayNumbers[even];
                arrayNumbers[even] = arrayNumbers[odd];
                arrayNumbers[odd] = temp;
            }
        }
        return arrayNumbers;
    }

137. Minimum size of Subarray for getting sum greater or equal to target value : https://leetcode.com/problems/minimum-size-subarray-sum/submissions/

public int minSubArrayLen(int target, int[] arrayNumbers) {
        int first, last, sum, window;
        first = 0;
        window = Integer.MAX_VALUE;
        while(first < arrayNumbers.length - 1) {
            last = first + 1;
            sum = arrayNumbers[first];
            while(sum < target && last < arrayNumbers.length) {
                sum += arrayNumbers[last];
                last++;
            }
            if(sum >= target) {
                window = Math.min(window, (last - first));
            }
            first++;
        }
        return window == Integer.MAX_VALUE ? 0 : window;
    }

138. Maintaining skyline : https://leetcode.com/problems/max-increase-to-keep-city-skyline/submissions/

import java.util.Arrays;

class java_rough {
    public static void main(String[] args) {
       int[][] grid = new int[][]{
        {3, 0, 8, 4}, 
        {2, 4, 5, 7},
        {9, 2, 6, 3},
        {0, 3, 1, 0}
       };

       int[] rowMax = new int[grid.length];
       int[] columnMax = new int[grid[0].length];
       int counter = 0;
       int temp;

       for(int i = 0; i < grid.length; i++) {
           for(int j = 0; j < grid[i].length; j++) {
               if(rowMax[i] < grid[i][j]) {
                   rowMax[i] = grid[i][j];
               }
           }
       }

       for(int i = 0; i < grid[0].length; i++) {
            for(int j = 0; j < grid.length; j++) {
                if(columnMax[i] < grid[j][i]) {
                    columnMax[i] = grid[j][i];
                }
            }
        }

        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[i].length; j++) {
                temp = (rowMax[i] < columnMax[j] ? rowMax[i] : columnMax[j]);
                if(grid[i][j] < temp) {
                    counter += (temp - grid[i][j]);
                }
            }
        }

        System.out.println(counter);
    }
}

139. You are given two arrays (without duplicates) nums1 and nums2 where nums1s elements are subset of nums2. 
Find all the next greater numbers for nums1's elements in the corresponding places of nums2 : https://leetcode.com/problems/next-greater-element-i/

import java.util.HashMap;

class java_rough {
    public static void main(String[] args) {
        int[] nums1 = new int[]{2,4};
        int[] nums2 = new int[]{1,2,3,4};
        int max, temp;
        HashMap<Integer, Integer> record= new HashMap<>();
        record.put(nums2[nums2.length - 1], -1);
        max = nums2[nums2.length - 1];
        for(int i = nums2.length - 2; i >= 0; i--) {
            temp = nums2[i + 1];
            while(nums2[i] > temp && temp != -1) {
                temp = record.get(temp);
            }
            max = temp;
            record.put(nums2[i], max);
        }

        for(int i = 0; i < nums1.length; i++) {
            System.out.println(record.get(nums1[i]));
        }
    }
}

140. Determinig dominoes fall direction : https://leetcode.com/problems/push-dominoes/submissions/

import java.util.HashMap;

class java_rough {
    public static void main(String[] args) {
        String dominoes = ".L.R...LR..L..";
        int lengthDominoes = dominoes.length();
        int[] forces = new int[lengthDominoes];
        int currentForce = 0;
        StringBuilder result = new StringBuilder("");

        for(int i = 0; i < lengthDominoes; i++) {
            if(dominoes.charAt(i) == 'R') {
                currentForce = lengthDominoes;
            } else if(dominoes.charAt(i) == 'L') {
                currentForce = 0;
            } else {
                if(currentForce > 0) {
                    currentForce--;
                }
            }
            forces[i] = currentForce;
        }

        currentForce = 0;

        for(int i = lengthDominoes - 1; i >= 0; i--) {
            if(dominoes.charAt(i) == 'L') {
                currentForce = -1 * lengthDominoes;
            } else if(dominoes.charAt(i) == 'R') {
                currentForce = 0;
            } else {
                if(currentForce < 0) {
                    currentForce++;
                }
            }
            forces[i] = forces[i] + currentForce;
        }

        for(int i = 0; i < lengthDominoes; i++) {
            if(dominoes.charAt(i) == '.' && forces[i] != 0) {
                if(forces[i] > 0) {
                    result.append('R');
                } else {
                    result.append('L');
                }
            } else {
                result.append(dominoes.charAt(i));
            }
        }

        System.out.println(result);

    }
}

141. Checking minimum number of rotations required for opening a lock : https://leetcode.com/problems/open-the-lock/submissions/

import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

class java_rough {
    public static void main(String[] args) {
        String[] deadends = new String[]{"0201","0101","0102","1212","2002"};
        String target = "0202";
        System.out.println(openLock(deadends, target));
    }

    public static int openLock(String[] deadends, String target) {
        Queue<String> record = new LinkedList<>();
        int turn = 0;
        HashSet<String> ends = new HashSet<>(Arrays.asList(deadends));
        HashSet<String> visited = new HashSet<>();
        String possibleChoice;
        record.add("0000");
        String temp;
        int size = 0;
        while(!record.isEmpty()) {
            size = record.size();
            while(size > 0) {
                temp = record.poll();
                size --;
                if(temp.equals(target)) {
                    System.out.println(temp);
                    return turn;
                }
                visited.add(temp);
                for(int i = 0; i < target.length(); i++) {
                    possibleChoice = temp.substring(0, i) + 
                    String.valueOf(temp.charAt(i) == '9' ? '0' : (temp.charAt(i) - '0' + 1)) + 
                    temp.substring(i + 1, target.length()); 

                    if(!ends.contains(possibleChoice) && !visited.contains(possibleChoice)) {
                        //System.out.println(possibleChoice);
                        record.add(possibleChoice);
                    }
                }

                for(int i = 0; i < target.length(); i++) {
                    possibleChoice = temp.substring(0, i) + 
                    String.valueOf(temp.charAt(i) == '0' ? '9' : (temp.charAt(i) - '0' - 1)) + 
                    temp.substring(i + 1, target.length()); 

                    if(!ends.contains(possibleChoice) && !visited.contains(possibleChoice)) {
                        //System.out.println(possibleChoice);
                        record.add(possibleChoice);
                    }
                }
            }
            turn++;
        }
        return turn;
    }
}

142. Finding max consecutive 1 in a 0/1 array with operations allowed to swap given 0 to 1 : https://leetcode.com/problems/max-consecutive-ones-iii/submissions/

class java_rough  {
    public static void main(String[] args) {
        int[] inputArray = new int[]{1,1,1,0,0,0,1,1,1,1,0};
        int allowedOperations = 2;
        System.out.println(longestOnes(inputArray, allowedOperations));
    }

    public static int longestOnes(int[] inputArray, int allowedOperations) {
        int first, last, maxWindow;
        first = 0;
        last = 0;
        maxWindow = 0;
        while(last < inputArray.length) {
            if(inputArray[last] == 1) {
                last++;
                
            } else {
                if(allowedOperations <= 0) { 
                    if(inputArray[first] == 0) {
                        allowedOperations++;
                    }
                    first++;
                } else {
                    allowedOperations--;
                    last++;
                }
            }
            maxWindow = maxWindow < (last - first) ? (last - first) : maxWindow;
        }
        return maxWindow;
    }
}

143. Finding partition in given string such that each character is present in one partition only and returning all such partitions length : https://leetcode.com/problems/partition-labels/submissions/

import java.util.ArrayList;
import java.util.List;

class java_rough {
    public static void main(String[] args) {
        String inputString = "ababcbacadefegdehijhklij";
        for(int i : partitionLabels(inputString)) {
            System.out.println(i);
        }
    }

    public static List<Integer> partitionLabels(String inputString) {
        List<Integer> result = new ArrayList<>();
        int temp;
        int start = 0;
        int end = 0;
        int[] alphabets = new int[26];
        for(int i = 0; i < inputString.length(); i++) {
            temp = (int) inputString.charAt(i);
            temp -= 97;
            alphabets[temp] = i;
        }
        for(int i = 0; i < inputString.length(); i++) {
            temp = (int) inputString.charAt(i);
            temp -= 97;
            end = Math.max(end, alphabets[temp]);
            if(i == end) {
                result.add(end - start + 1);
                start = end + 1;
                end = 0;
            }
        }
        return result;
    }
}

145. Finding number that is repeated when numbers given in an array are between 1 and length of array : https://leetcode.com/problems/find-all-duplicates-in-an-array/submissions/

import java.util.ArrayList;
import java.util.List;

class java_rough {
    public static void main(String[] args) {
        int[] inputArray = new int[]{4,3,2,7,8,2,3,1};
        findDuplicates(inputArray).forEach(num -> System.out.println(num));
    }

    public static List<Integer> findDuplicates(int[] nums) {
        List<Integer> result = new ArrayList<>();
        int index;
        for(int i = 0; i < nums.length; i++) {
            index = Math.abs(nums[i]) - 1;
            if(nums[index] < 0) {
                result.add(index + 1);
            } else {
                nums[index] = -1 * nums[index];
            }
        }
        return result;
    }
}

146. Checking asteroid trajectories for collision : https://leetcode.com/problems/asteroid-collision/submissions/

import java.util.Stack;

class java_rough {
    public static void main(String[] args) {
        int[] asteroids = new int[]{-2,-2,1,-2};
        for (int i : asteroidCollision(asteroids)) {
            System.out.println(i);
        }
    }

    public static int[] asteroidCollision(int[] asteroids) {
        Stack<Integer> orderAsteroids = new Stack<>();
        int asteroidSize;
        for(int i = 0; i < asteroids.length; i++) {
            asteroidSize = asteroids[i];
            if(orderAsteroids.isEmpty() || asteroidSize > 0) {
                orderAsteroids.push(asteroidSize);
            } else {
                int peakElement = orderAsteroids.peek();
                int currentAstreoid = 0;
                if(peakElement > 0) {
                   while(!orderAsteroids.isEmpty() && peakElement > 0) {
                        if(peakElement < Math.abs(asteroidSize)) {
                            orderAsteroids.pop();
                            currentAstreoid = asteroidSize;
                            if(!orderAsteroids.isEmpty()) {
                                peakElement = orderAsteroids.peek();
                            }
                        } else if(peakElement == Math.abs(asteroidSize)) {
                            orderAsteroids.pop();
                            currentAstreoid = 0;
                            break;
                        } else {
                            currentAstreoid = 0;
                            break;
                        }
                   }
                   if(currentAstreoid != 0) {
                       orderAsteroids.push(currentAstreoid);
                   }
                } else {
                    orderAsteroids.push(asteroidSize);
                }
            }
        }
        int[] result = new int[orderAsteroids.size()];
        for(int i = orderAsteroids.size() - 1; i >= 0; i--) {
            result[i] = orderAsteroids.pop();
        }
        return result;
    }
}

147. Rotate a given square matrix : https://leetcode.com/problems/rotate-image/

class java_rough {
    public static void main(String[] args) {
        int[][] matrix = {
            {1,2,3},
            {4,5,6},
            {7,8,9}
        };
        matrix = rotate(matrix);
        for(int i = 0; i < matrix.length; i++) {
            for(int j = 0; j < matrix.length; j++) {
                System.out.print(matrix[i][j]);
            }
            System.out.println();
        }
    }

    public static int[][] rotate(int[][] matrix) {
        int temp;
        for(int i = 0; i < matrix.length; i++) {
            for(int j = i; j < matrix.length; j++) {
                if(i != j) {
                    temp = matrix[i][j];
                    matrix[i][j] = matrix[j][i];
                    matrix[j][i] = temp;
                }
            }
        }

        for(int i = 0; i < matrix.length; i++) {
            int first, last;
            first = 0;
            last = matrix.length - 1;
            while(first < last) {
                temp = matrix[i][first];
                matrix[i][first] = matrix[i][last];
                matrix[i][last] = temp;
                first++;
                last--;
            } 
        }
        return matrix; 
    }
}

148. Return number of possible subsets made of contiguous sub-array whose product is less than given target value : https://leetcode.com/problems/subarray-product-less-than-k/submissions/

class java_rough {
    public static void main(String[] args) {
        int[] nums = new int[]{1,1,1};
        int target = 2;
        System.out.println(numSubarrayProductLessThanK(nums, target));
    }

    public static int numSubarrayProductLessThanK(int[] nums, int target) {
        if(target <= 1) {
            return 0;
        }

        int first, last, subSets, product;
        first = 0;
        last = 0;
        subSets = 0; 
        product = 1;

        while(last < nums.length) {
            product *= nums[last];
            if(product >= target) {
                while(product >= target && first <= last) {
                     product /= nums[first];
                     first++;
                }
            }
            subSets += (last - first + 1);
            last++;
        }
        return subSets;
    }
}

149. Finding sum of deepest leaves in a tree : https://leetcode.com/problems/deepest-leaves-sum/submissions/

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int deepestLeavesSum(TreeNode root) {
        Queue<TreeNode> traversal = new LinkedList<>();
        int sum = 0;
        traversal.add(root);
        traversal.add(null);
        TreeNode temp;
        while(!traversal.isEmpty()) {
            temp = traversal.poll();
            if(temp == null) {
                if(!traversal.isEmpty()) {
                    traversal.add(null);
                    sum = 0;
                }
            } else {
                if(temp.left != null) {
                    traversal.add(temp.left);
                }
                if(temp.right != null) {
                    traversal.add(temp.right);
                }
                sum += temp.val;
            }
        }
        return sum;
    }
}

150. Task Scheduler : https://leetcode.com/problems/task-scheduler/submissions/

import java.util.Arrays;

class java_rough {
    public static void main(String[] args) {
        char[] tasks = new char[]{'A','A','A','B','B','B'};
        int coolOffPeriod = 2;
        System.out.println(leastInterval(tasks, coolOffPeriod));
    }

    public static int leastInterval(char[] tasks, int coolOffPeriod) {
        char[] frequencies = new char[26];
        int temp, idleSlots, index, mostFrequent;
        for(int i = 0; i < tasks.length; i++) {
            temp = (int) tasks[i];
            temp -= 65;
            frequencies[temp]++;
        }
        Arrays.sort(frequencies);
        mostFrequent = frequencies[25];
        idleSlots = (mostFrequent - 1) * coolOffPeriod;
        index = 24;

        while(idleSlots > 0 && index >= 0) {
            idleSlots -= (Math.min(mostFrequent - 1, frequencies[index]));
            index --;
        }
        return idleSlots > 0 ? idleSlots + tasks.length : tasks.length;
    }

}

151. Completing checkers game : https://leetcode.com/problems/surrounded-regions/submissions/

class java_rough {
    public static void main(String[] args) {
        char[][] board = new char[][]{
            {'X','X','X','X'},
            {'X','0','0','X'},
            {'X','X','0','X'}, 
            {'X','0','X','X'},
        };
        solve(board);
    }

    public static void solve(char[][] board) {
        for(int i = 0; i < board.length; i++) {
            if(board[0][i] == '0') {
                board = updateBoard(board, 0, i);
            }
            if(board[board.length - 1][i] == '0') {
                board = updateBoard(board, board.length - 1, i);
            }
            if(board[i][0] == '0') {
                board = updateBoard(board, i, 0);
            }
            if(board[i][board.length - 1] == '0') {
                board = updateBoard(board, i, board.length - 1);
            }
        }
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board.length; j++) {
                if(board[i][j] == 'F') {
                    System.out.print('0');
                } else {
                    System.out.print('X');
                }
            }
            System.out.println();
        }
    }

    public static char[][] updateBoard(char[][] board, int x, int y) {
        if(x >= 0 && x < board.length && y >= 0 && y < board.length && board[x][y] == '0') {
            board[x][y] = 'F';
            board = updateBoard(board, x + 1, y);
            board = updateBoard(board, x - 1, y);
            board = updateBoard(board, x, y + 1);
            board = updateBoard(board, x, y - 1);
        }
        return board;
    }
}

152. Finding out which queens can attack the king in given 8 * 8 chess board : https://leetcode.com/problems/queens-that-can-attack-the-king/submissions/

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class java_rough {
    public static void main(String[] args) {
        int[][] queens = new int[][]{
            {0,1},{1,0},{4,0},{0,4},{3,3},{2,4}
        };
        int[] king = new int[]{0 , 0};
        System.out.println(queensAttacktheKing(queens, king).toString());
    }

    public static List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        List<List<Integer>> result = new ArrayList<>();
        boolean[][] visited = new boolean[8][8];
        int x, y;
        for(int i = 0; i < queens.length; i++) {
            x = queens[i][0];
            y = queens[i][1];
            visited[x][y] = true;
        }
        
        int[] allowedMoves = new int[]{-1, 0 ,1};
        for(int i = 0; i < allowedMoves.length; i++) {
            for(int j = 0; j < allowedMoves.length; j++) {
                if(allowedMoves[i] == 0 && allowedMoves[j] == 0) continue;
                x = king[0];
                y = king[1];
                while(x + allowedMoves[i] >= 0 && x + allowedMoves[i] < 8 && y + allowedMoves[j] >=0 && y + allowedMoves[j] < 8) {
                    x += allowedMoves[i];
                    y += allowedMoves[j];
                    if(visited[x][y]) {
                        result.add(Arrays.asList(x, y));
                        break;  
                    }
                } 
            }
        }
        return result;
    }
}

153. Pattern matching with wildcards * and ? 

import java.util.Arrays;

class  java_rough {
    public static void main(String[] args) {
        String pattern = "?*d*";
        String text = "abcd";
        System.out.println(stringPatternMatcher(pattern, text));

    }

    public static boolean stringPatternMatcher(String pattern, String text) {
        //sampleSpace created for storing edge cases data that can be hard coded before  going in to loop
        boolean[][] sampleSpace = new boolean[text.length() + 1][pattern.length() + 1];
        for(int i = 0; i <= text.length(); i++) {
            Arrays.fill(sampleSpace[i], false);
        }
        // since null pattern will match null string
        sampleSpace[0][0] = true;

        //Since if a * charater is present in a null string that would also be true so getting value from column at top so that if there is any charater or ? it will be false there on.
        for(int i = 1; i  <= pattern.length(); i++) {
            if(pattern.charAt(i - 1) == '*') {
                sampleSpace[0][i] = sampleSpace[0][i - 1];
            }
        }

        for(int i = 1; i <= text.length(); i++) {
            for(int j = 1; j <= pattern.length(); j++) {
                if(pattern.charAt(j - 1) == '*') {
                    System.out.println("got in first");
                    sampleSpace[i][j] = sampleSpace[i - 1][j] || sampleSpace[i][j - 1];
                } else if(pattern.charAt(j - 1) == '?' || pattern.charAt(j - 1) == text.charAt(i - 1)) {
                    sampleSpace[i][j] = sampleSpace[i  -1][j - 1];
                    System.out.println("got in second");
                } else {
                    sampleSpace[i][j] = false;
                    System.out.println("got in third");
                }
                System.out.println("setting " + sampleSpace[i][j] + " for row " + text.charAt(i - 1) + " and column " + pattern.charAt(j - 1));
            }
        }
        return sampleSpace[text.length()][pattern.length()];
    }
}

154. Finding running median for given elements
import java.util.Comparator;
import java.util.PriorityQueue;

class java_rough {
    public static void main(String[] args) {
        int[] numbers = new int[]{12, 4, 5, 3, 8, 7};
        getRunningMedian(numbers);
    }

    public static void getRunningMedian(int[] numbers) {
        PriorityQueue<Integer> firstHalf = new PriorityQueue<>(new Comparator<Integer>(){
            @Override
            public int compare(Integer value_1, Integer value_2) {
                return -1 *(value_1 - value_2);
            }
        });
        PriorityQueue<Integer> secondHalf = new PriorityQueue<>();
        for(int i  = 0; i < numbers.length; i++) {
            addNumberToHeap(numbers[i], firstHalf, secondHalf);
            rebalanceHeaps(firstHalf, secondHalf);
            printMedian(firstHalf, secondHalf);
        }
    }

    public static void addNumberToHeap(int number, PriorityQueue<Integer> firstHalf, PriorityQueue<Integer> secondHalf) {
        if(firstHalf.size() == 0 || firstHalf.peek() >= number) {
            firstHalf.add(number); 
        } else {
            secondHalf.add(number);
        }
    }

    public static void rebalanceHeaps(PriorityQueue<Integer> firstHalf, PriorityQueue<Integer> secondHalf) {
        if(Math.abs(firstHalf.size() - secondHalf.size()) == 2) {
            PriorityQueue<Integer> biggerHeap, smallerHeap;
            biggerHeap = firstHalf.size() > secondHalf.size() ? firstHalf : secondHalf;
            smallerHeap = firstHalf.size() > secondHalf.size() ? secondHalf : firstHalf;
            smallerHeap.add(biggerHeap.poll());
        }
    }

    public static void printMedian(PriorityQueue<Integer> firstHalf, PriorityQueue<Integer> secondHalf) {
        int firstHalfSize = firstHalf.size();
        int secondHalfSize = secondHalf.size();
        double runningMedian;

        runningMedian = (double)(firstHalfSize + secondHalfSize) % 2 == 0 ? 
            (double)(firstHalf.peek() + secondHalf.peek()) / 2 : 
            (firstHalfSize > secondHalfSize ? firstHalf.peek() : secondHalf.peek());

        System.out.println(runningMedian);
    }
}

155. Cookie mix problem : https://www.hackerrank.com/challenges/jesse-and-cookies/problem?utm_campaign=challenge-recommendation&utm_medium=email&utm_source=7-day-campaign

import java.util.PriorityQueue;
import java.util.Queue;

class java_rough {
    public static void main(String[] args) {
        int minimumSweetness = 7;
        int numberOfCookies = 6; 
        int[] cookies = new int[]{1, 2, 3, 9, 10, 12};
        int minumumSweetnessCookie, secondMinimumSweetnessCookie, newCookieSweetness;
        int operations = 0;

        Queue<Integer> currentSweetness = new PriorityQueue<>();

        for(int i = 0; i < numberOfCookies; i++) {
            currentSweetness.add(cookies[i]);
        }

        minumumSweetnessCookie = currentSweetness.poll();

        while(minumumSweetnessCookie < minimumSweetness && currentSweetness.size() >= 2) {
            secondMinimumSweetnessCookie = currentSweetness.poll();
            newCookieSweetness = minumumSweetnessCookie + (2 * secondMinimumSweetnessCookie);
            System.out.println("Created new cookie from " + minumumSweetnessCookie + " and " 
                                                            + secondMinimumSweetnessCookie 
                                                            + " to get "
                                                            + newCookieSweetness);
            currentSweetness.add(newCookieSweetness);
            minumumSweetnessCookie = currentSweetness.poll();
            operations++;
        }

        if(minumumSweetnessCookie < minimumSweetness) {
            System.out.println(-1);
        } else {
            System.out.println(operations);
        }
        
    }
}

156. Creating a string given its huffman coded output and tree : https://www.hackerrank.com/challenges/tree-huffman-decoding/problem

class java_rough {
    void decode(String codedString, Node root) {
        int index = 0;
        char characterToPick;
        Node node = root;
        Node previousNode = null;
        StringBuilder result = new StringBuilder("");
        while(index < codedString.length()) {
            if(codedString.charAt(index) == '0') {
                node = node.left;
            } else {
                node = node.right;
            }
            if(node == null) {
                result.append(previousNode.data);
                previousNode = null;
                node = root;
                index --;
            } else {
                previousNode = node;
            }
            index ++;
        }
        if(previousNode != null) {
            result.append(previousNode.data);
        }
        System.out.println(result.toString());
    }
}



//https://www.geeksforgeeks.org/find-whether-subarray-form-mountain-not/
//Ensuring Thread Safety for singleton class
//e15844676c314f9b050bf5201f992d9fa57c155d488c19a233cccbdb135911d6


Important Algos :-
1. DFS
2. BFS
3. Matching brackets using Stacks
4. Questions on Hash Tables like most zeros in an matrix
5. Trie

//Find the 2nd smallest number in an array  
//Pascal triangle returns the value given height and widh  
//Java Garbage collection questions
//Threads Concept 
//Valid comments in code
//Java 8 concepts  
//Graphs
//Ensuring Thread Safety for singleton class

//When to use static
//Attendance system to find out consecutive presents
//Big integer / Big Decimal
//Pagation in JS
//Indexing in DB
//Why to use right join
//Uses of static and inner static nested classes
//Advantages of iterators and differance between iterators of different colletions.
//Differance between git merge and git rebase.
//Advantages of spring boot
//Hibernate - persistance layer
//https://artoftesting.com/interviewSection/sql-queries-for-interview.html


