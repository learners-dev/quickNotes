========================================== MISLLANEOUS ===============================================================
1. Resizing of array should be done exponenetially to get insertion time complexity as O(1)

2. Unchecked exceptions which are subtypes of Error and RuntimeException. Methods also don’t have to declare to throw unchecked 
   exceptions. It’s because programs typically cannot be recovered from unchecked exceptions.

3. In computer programming, boilerplate code or just boilerplate refers to sections of code that have to be included in many places 
   with little or no alteration. It is often used when referring to languages that are considered verbose, i.e. the programmer must 
   write a lot of code to do minimal jobs.

4. Common OOPs concepts: (For Symbols: https://javapapers.com/oops/association-aggregation-composition-abstraction-generalization-realization-dependency/)
	1. Association: Two independent entities being related. EX: A Student and a Faculty are having an association.
	
	2. Aggregation: Aggregation is a special case of association.It signifies one object having another object as its property.
	   For example consider two classes Student class and Address class. Every student has an address so the relationship between 
	   student and address is a Has-A relationship. But if you consider its vice versa then it would not make any sense as an 
	   Address doesn’t need to have a Student necessarily.
	
	3. Composition: Composition is a special case of aggregation. It signifies one object having another object as its property but 
	   the inner object cannot exist without the main outer object. EX: Body: Heart

	4. Generalization: Consider there exists a class named Person. A student is a person. A faculty is a person. Therefore here the 
	   relationship between student and person, similarly faculty and person is generalization.

	5. Realization: The relationship between the interface and the implementing class.

5. B-trees are used to manage indexes in DBMS.

6. AOP or Aspect Oriented programming is setting tasks as aspects and instead of calling them specifically in you function configuring
   them to rum before/after a task Execution.

7. Functional interface: A functional interface is an interface that contains only one abstract method. Comparator is a functional 
   interface because there's only one unimplemented abstract method: compare(T o1, T o2). 
   EX: Implementing the compare method:
		personList.sort(new Comparator<Employee>() {

        @Override
        public int compare(Employee e1, Employee e2) {
            return e1.getName().compareTo(e2.getName());
        });

8. Using lambda expression the declaration can be implified to: personList.sort(Comparator.comparing((Person p) -> p.name));

9. The main class for a Simple springboot application 

		@SpringBootApplication
		public class Application {

			public static void main(String[] args) {
				SpringApplication.run(Application.class, args);
			}

		}

10. The@ControllerAdvice annotation allows us to consolidate our multiple, scattered @ExceptionHandlers from before into 
    a single, global error handling component.

11. LocalDate myObj = LocalDate.now(); // Create a date object

12. Overriding equals and hasCode function in java class
			class java_rough {
				int age;
				String name;
				@Override
				public boolean equals(Object obj) {
					if(this == obj) {
						return true;
					}
					if(this == null || obj == null) {
						return false;
					}
					java_rough newObj = (java_rough) obj;
					return this.age == newObj.age && this.name.equals(newObj.name);
				}

				@Override
				public int hashCode() {
					int result = 0;
					result = (int) (value / 11);
					return result;
				}
			}
========================================== JAX-RS ===============================================================
1. REST services borrow the below mentioned mechanisms from HTTP :-
    -   Resource based URL's
    -   HTTP methods are used {GET, PUT, POST, DELETE}
    -   Responce responds back with appropriate HTTP status codes.
    -   Responce should have appropriate headers like content-type.

2. The REST Resource URI's are of 2 types
    -   Instance URI - Get details for single Resource. EX - /messages/{messageId}
    -   Collection URI - Get a collection of details. EX - /messages

3. Query parameters can be used for Pagination and Filtering. EX - /messages/{messageId}?results=10&year=2014.

 @GET
    public String getOrders(@QueryParam("stateCode") String stateCode) {
        return stateCode != null ? getOrdersByState(stateCode)
                                  : getAllOrders();
    }

4. When creating a new resource instance we use the POST method with collections URI. EX - /messages

5.  Idempotent methods - GET, PUT, DELETE {Can be repeated}
    Non-Idempotent methods - POST

6. The different error codes classes are mentioned below :-
    -   1XX - Informational(100: Continue, 101: Switching Protocols)
    -   2XX - Success(200: OK, 201: created, 202: Accepted)
    -   3XX - Redirection(301 Moved Permanently, 302 Found, 305 Use Proxy)
    -   4XX - Client error(400 Bad Request, 401 Unauthorized, 403 Forbidden,  404 Not Found)
    -   5XX - Server error(500 Internal Server Error, 501 Not Implemented, 502 Bad Gateway, 503 Service Unavailable)

7. HATEOAS is a way to provide client link to various resources as a responce to an api call so that no URL creation has to be done at client side.

public Message getMessage(@PathParam("messageId") long messageId, @Context UriInfo uriInfo) {
		Message message = MessageService.getMessage(messageId);
		String uri = uriInfo.getBaseUriBuilder()
				.path(MessageResource.class)
				.path(Long.toString(messageId))
				.build()
				.toString();
		message.addLink(uri, "self");

8. In SOAP services only one API end point is exposed and the request body contains details for what operation is to be performed.

9. According to Richardson Maturity Model below mentioned are the levels of REST service achived :-

    -   Lvl 0 - Using single API endpoint
    -   Lvl 1 - Using resource based URI'service
    -   Lvl 2 - Using HTTP methods {POST, PUT etc}
    -   Lvl 3 - HATEOAS

10. JAX-RS is a set of interfaces and annotations that has api's for REST services. Library classes like jersey or RESTeasy 
implement these interfaces and make sense of the annotations wherever the JAX-RS api's are used. Every JAX-RS Library comes
with a copy of JAX-RS. Methods you get from Jersey for basic rest API are:
@GET
	@Path("/{messageId}")
	@Consumes(MediaType.APPLICATION_JSON)
	@Produces(MediaType.APPLICATION_JSON)
	@QueryParam("year") int year,
	@BeanParam MessageFilterBean messageFilterBean
	public Message getMessage(@PathParam("messageId") long messageId) {
		return MessageService.getMessage(messageId);
	}

11. jaxb is used by java to convert response to XML file.

12. Always have a no-arg constructor when returning XML/JSON responce as the associated libraries uses it internally.
 
13. @QueryParam URL design = http://localhost:8080/messanger/webapi/messages?start=0&size=2

14. Some important params that we can extract from incoming request :-

    -   @MatrixParam    -> Similar as @QueryParam but uses ; to seprate values;
    -   @HeaderParam    -> Get token value sent in header.
    -   @CookieParam    -> Get token value sent in cookie.
    -   @Context        -> This cannot annotate to any datatype but only few selected ones like 'class:UriInfo, HttpHeaders' and 
                           is used to get details about the request without specifying details if you don't know them before hand,
                           like AbsolutePath, ContextPath, QueryParams, Cookies etc

15. Responce object can be returned instead of actual object as Responce class has methods to return any class entity along with
editing HTTP status codes (.status(Status.CREATED)), return an object/value (.entity), sending URI along with status code 201
(.created(new URI("/messanger/webapi/messages/ + message.getId())));

EX - 
@POST
	public Response addMessage(Message message, @Context UriInfo uriInfo) {
		
		Message newMessage = messageService.addMessage(message);
		String newId = String.valueOf(newMessage.getId());
		URI uri = uriInfo.getAbsolutePathBuilder().path(newId).build();
		return Response.created(uri)
				.entity(newMessage)
				.build();
	}

16. A basic exception handlind example for REST calls :-

    //method that may have exception scenario
    public Message getMessage(long id) {                                
            Message message = messages.get(id);
            if (message == null) {
                throw new DataNotFoundException("Message with id " + id + " not found");
            }
            return message;
        }

    public class DataNotFoundException extends RuntimeException {       //Custom exception handling class
	private static final long serialVersionUID = -6328286661536343936L;
	public DataNotFoundException(String message) {
		super(message);
	}

    //Error object Class
    @XmlRootElement
    public class ErrorMessage {

	private String errorMessage;
	private int errorCode;
	private String documentation;
	
	public ErrorMessage() {
		
	}
		
	public ErrorMessage(String errorMessage, int errorCode, String documentation) {
		super();
		this.errorMessage = errorMessage;
		this.errorCode = errorCode;
		this.documentation = documentation;
	}


    // Class to implement and Map exception to responce when thrown
    @Provider //annotation to let jax.rs know that this class exists
    public class DataNotFoundExceptionMapper implements ExceptionMapper<DataNotFoundException> { 

	@Override
	public Response toResponse(DataNotFoundException ex) {
		ErrorMessage errorMessage = new ErrorMessage(ex.getMessage(), 404, "http://javabrains.koushik.org");
		return Response.status(Status.NOT_FOUND)
				.entity(errorMessage)
				.build();
	}
	

    //Providing generic exception handler class
    @Provider
    public class GenericExceptionMapper implements ExceptionMapper<Throwable> {

	@Override
	public Response toResponse(Throwable ex) {
		ErrorMessage errorMessage = new ErrorMessage(ex.getMessage(), 500, "http://javabrains.koushik.org");
		return Response.status(Status.INTERNAL_SERVER_ERROR)
				.entity(errorMessage)
				.build();
	} 

17. The Jersey Library provides you with 'WebApplicationException' where you can set from a set of constructor option
on how to handle an error scenario that may happen in a web-application.
EX - 
    public Comment getComment(long messageId, long commentId) {
		ErrorMessage errorMessage = new ErrorMessage("Not found", 404, "http://javabrains.koushik.org");
		Response response = Response.status(Status.NOT_FOUND)
				.entity(errorMessage)
				.build();
		
		Message message = messages.get(messageId);
		if (message == null) {
			throw new WebApplicationException(response); //Creating your responce and sending
		}
		Map<Long, Comment> comments = messages.get(messageId).getComments();
		Comment comment = comments.get(commentId);
		if (comment == null) {
			throw new NotFoundException(response); //Using a standard error code part of WebApplicationException
		}
		return comment;
	}  

18. Content negociation is client and server using header values to communicate type (XML, JSON etc) that will be sent and 
received amongst them. One method to enable multiple types in server side in jersey is :
@Consumes(value = { MediaType.APPLICATION_JSON, MediaType.TEXT_XML })
You can set @Consumes or @Produces at method levels as well, based on this request of same HTTP method will select method on type 
sent from client.
==================================================MAVEN Fundamentals==============================================================
1. POM has project name and its group and artifact ids
2. POM needs only entry level dependancy
3. COMMANDS :
	- mvn compile (uses compile plugin, no need to mention in pom if no custom config is required)
	- mvn package -> creates JAR/WAR
	- mvn clean -> removes target folder from project
	- java -cp *.jar class_name -> To run main method in class_name from jar
	- mvn jetty:run(Uses jetty plugin, you can use scan interval for getting new changes deployed)
4. Maven creates a local repo and checks it first for artifacts then goes to internet maven repo
5. PHASES OF MAVEN BUILDCYCLE:
	Validate (check if all information necessary for the build is available) -> Compile -> Test -> package -> 
	install(pushes artifact to local repo) -> deploy (pushes artifact to remote repo)
6. Default scope in maven is compile for dependancy.
7. Maven dependency scope provided is used during build and test the project. They are also required to run, but should not exported, 
   because the dependency will be provided by the runtime, for instance, by servlet container or application server.

=================================================SPRING Fundamentals(IOC)==============================================================
Summary :-
Two distinct types of Spring IoC Containers (IoC is also known as dependency injection (DI). It is a process whereby objects define 
their dependencies, that is, the other objects they work with, only through constructor arguments, arguments to a factory method, 
or properties that are set on the object instance after it is constructed or returned from a factory method. The container then 
injects those dependencies when it creates the bean. This process is fundamentally the inverse, hence the name Inversion of Control
(IoC), of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes, 
or a mechanism such as the Service Locator pattern.) which are a BeanFactory Container and ApplicationContext Container in Spring 
Framework:-

- Spring BeanFactory Container is the simplest container which provides basic support for DI. It is defined by org.springframework
.beans.factory.BeanFactory interface. A BeanFactory is essentially nothing more than the interface for an advanced factory capable 
of maintaining a registry of different beans and their dependencies. The BeanFactory enables you to read bean definitions and 
access them using the bean factory.
- ApplicationContext container adds more enterprise-specific functionality such as the ability to resolve textual messages from a 
properties file and the ability to publish application events to interested event listeners. This container is defined by the org
.springframework.context.ApplicationContext interface.

1. Namespace declaration in applicationContext.xml which is located in src/main/resources file which is used for Spring configuration 
are basically libraries that help in configuration and Validation operations.

2. Beans are  POJOs that Spring configures. Simply put mentioning in file that we need a bean allows you to use it instead of 
hard-coding it with new keybord in a class. Also use interfaces while configuring beans as principal of 'Sepration of Concerns' helps 
you to update the implementation class whenever you want without need of changing applicationContext.xml.

3. To enable annotation based bean configuration for your project add the below in applicationContext.xml :-
	<context:annotation-config/> //telling that we use annotations
	<context:component-scan base-package="com.project"/> //telling where is the root folder for the files that are bound by annotations

4. Annotation are of 3 types at class level which are symantically same but have different significance by convention as mentioned :-
	- @Component -> Any POJO
	- @Service -> Class that implements business logic
	- @Repository -> Classes that interact with DB.

5. Using @Autowire annotation you can add any class as dependancy in your class in 3 ways as shown below :-
	- Member level :-
		@Autowire
		private RequiredClass1 requiredClass1;
	
	- Setter Injection :-
		@Autowire
		public void setRequiredClass(RequiredClass1 requiredClass1) {
			this.requiredClass1 = requiredClass1;
		}

	- Constructor Injection :-
		@Autowire
		public CurrentClass(RequiredClass1 requiredClass1) {
			this.requiredClass1 = requiredClass1;
		}

6. Using java you can also create you spring configuration file as shown below. You can name your file anything just use the same 
name in your main method when running application and giving name of config file.

	@Configuration
	@ComponentScan("com.packageRoot")
	public class AppConfig {
		@Bean(name = "serviceClass")
		public MyServiceInterface getServiceClassBean() {
			return new MyServiceImpl();
		}
	}

7. Any bean has 5 scopes as described below :-
	- Singleton - Single instance per Spring container and is the default bean scope. Bean is created before code asks for it.
				  Below is an code snippet.
	@Service
	@Scope("singleton")
	public class CurrentClass() {
		//functions
	}

	- Prototype - This scopes a single bean definition to have any number of object instances. Bean is created after code asks for it.
	 			  Below is an code snippet.
	@Service
	@Scope("prototype")
	public class CurrentClass() {
		//functions
	}

	** As a rule, use the prototype scope for all state-full beans and the singleton scope for stateless beans.**

	For web projects
	- Request - This scopes a bean definition to an HTTP reques  t; that is each and every HTTP request will have its own 
	instance of a bean created off the back of a single bean definition.
	- Session - This scopes a bean definition to an HTTP session.
	- Global  - This scopes a bean definition to a global HTTP session



==================================================SPRING MVC FRAMEWORK(SOC)=============================================================

1. Common Vocabulary :-
	- Dispatcher Servlet - The entry / configuration point of application. Front controller class maintained by Spring MVC.
							Uses @Controller annotation to identify all controller classes.
	- Handles the request and determines which view to route to.
	- Request Mapping - The URL and the HTTP method type the function is bind to.
	- View Resolver - Used to locate JSP pages
	- Servlet - config - configuration file per Dispatcher Servlet
	- POJO - Plain Old Java Object, which has no arg constructor and has private fields with associated getter/setter methods.
	- Bean - It is a POJO that is configured by Spring to be used within the application.
	- Common Annotations: 
		@Controller
		@RequestMapping
		@PathVariable
		@RequestParam
		@ModelAttribute
		@RequestBody and @ResponseBody:
						EX:	public @ResponseBody List<User> listAllUsers(@RequestBody UserList users) {
								return userService.findAllUsers();
							}
		@RequestHeader and @ResponseHeader

2. Basic Components of Spring MVC project :-
	- web.xml
	- servlet-config.xml
	- Controller class - Class that has the annotations
	- View - JSP pages to desplay rendered datatype

3. Declaring your Dispatcher Servlet in web.xml:-

		<servlet>
			<servlet-name>fitTrackerServlet</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
			<init-param>
				<param-name>contextConfigLocation</param-name>
				<param-value>/WEB-INF/config/servlet-config.xml</param-value>
			</init-param>
		</servlet>
		
		<servlet-mapping>
			<servlet-name>fitTrackerServlet</servlet-name>
			<url-pattern>*.html</url-pattern>
		</servlet-mapping>

4. Adding servlet-config.xml under WEB-INF to tell that we will use annotations for configuration and where classes with annotations
will be.

	<mvc:annotation-driven />
		<context:component-scan base-package="com.pluralsight.controller" />
5. Telling about location of your JSP pages using 'p' which stands for property namespace. Namespaces are internal utility methods.

<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" p:prefix="/WEB-INF/jsp/" p:suffix=".jsp" />

6. For Validation of data sent from client you can use JSR-303 standards which involve use of dependancy 'hibernate-validator'.

public String updateGoal(@Valid @ModelAttribute("goal")Goal goal, BindingResult result) { //@Valid annotation starts hibernate-validator rules check

	
		System.out.println("result has errors: " + result.hasErrors()); //result object tells if the constraints are violated
		
		System.out.println("Minutes updated: " + goal.getMinutes());
		
		return "redirect:addMinutes.html";
		
	}

========================================JUNIT and MOKITO===============================================

1. A unit test has 4 phases :-
	- Setup
	- Execution of method under test
	- Verification by asserting result of the test
	- Teardown of resources created
	
2. Junit key points :-
	- @Test annotation marks a function as test classes
	- Assert class has many static functions to verify output
	- @Before and @After runs before and after every @Test respectively, whereas @BeforeClass and 
	@AfterClass runs once per class.
	
3. Basic Mokito functions :-
	- Mockito.mock(sample.class) to create mock of a class done during setup phase usually.
	- Mokito.when(className.functionName()).thenReturn(output) in setup to provide mocked output.
	- Mokito.verify(mockOrderDao).findById(idValue)

4. You can also use @Mock for your dependancy classes, but remember to add below in @Before part :-
	- MokitoAnnotations.initMocks(this);

5. Common when/then constraints on mocked methods are :-
	- thenReturn -> Returns an object/value
	- thenThrow -> Returns an exception type
	- doThrow -> In case of void methods use first get the doThrow output in a Stubber object and then
	on that object apply your when condition.
	- thenCallRealMethod -> calls the actual method for the mocked class.

6. Mokito allows you to test if your method was called :-
	- Mokito.verify(className, VerificationSettings.times(number_of_times_invoked)).functionName();
	- You can also use times, atleast(n), atleastOnce(), atmost(n), never

7. Argument matching while mocking functions uses common Matcher classes below functions :-
 EX: when(mockFoo.bool(anyString(), anyInt(), any(Object.class))).thenReturn(true);
	- Matchers.eq() -> Used for equals as you have to use implicit or explicit matching only for all fields.
	- (data_type) Matchers.any()
	- Matchers.anyInt() and other generic datatypes
	- Matchers.any(String.class)
	- Matchers.eq/contains/startsWith/EndsWith/match(regex) can be used for strings

8. To verify that services are executed in order we can use the below mentioned functionalities :-
	- InOrder inOrderVerifier = Mockito.inOrder(mockService1, mockService2);
		 inOrderVerifier.verify(mockService1).function1();
		 inOrderVerifier.verify(mockService2).function2();
	-  When return for same function needs to be different
		when(mockFoo.someMethod())
            .thenReturn(0)
            .thenReturn(1)
            .thenReturn(-1); //any subsequent call will return -1

9. Mockito provides a utility to capture arguments tha are being passed to functiona calls to improve the scope 
of what we can to test. The below code snippet demos that approach :-

	ArgumentCaptor<className> classArgumentCaptor = ArgumentCaptor.forClass(className.class);
	Mokito.verify(mockOrderDao).methodName(classArgumentCaptor.capture());
	Assert.assertEquals(expectedValue, classArgumentCaptor.someFunction());


==========================================================Lambda Expressions======================================================
ABOUT:
	1. Passing function as method reference(EX: System.out::println) or (parameters -> Function body(Single line or multiple lines 
		function body contained inside {} and separated by ;))

	2. Lambdas can only be defined for functional interfaces that are interfaces with exactly one abstract method.

	3. The declaration for filter looks like: Stream<T> filter(Predicate<? super T> predicate);

	4. A predicate function can be defined as: 
			public static Predicate<Employee> isAdultMale() 
			{
				return p -> p.getAge() > 21 && p.getGender().equalsIgnoreCase("M");
			}

	5. Optional is a container object used to contain not-null objects. Optional object is used to represent null with absent value,
		which helps in avoiding null pointer checks.
	
	6. Example of important methods:
				import java.util.Arrays;
				import java.util.List;
				import java.util.Optional;

				class java_rough {
					public static void main(String[] args) {
						Optional<String> s1 = Optional.empty();
						Optional<String> s2 = Optional.of("value");
						Optional<String> s3 = Optional.ofNullable("value_1");
						Optional<String> s4 = Optional.ofNullable(null);
						Optional<List<String>> s5 = Optional.of(Arrays.asList(new String[]{"hi", "there"}));

						if(s1.isPresent()) {
							System.out.println(s1.get());
						} else {
							System.out.println(s1);
						}

						if(s2.isPresent()) {
							System.out.println(s2.get());
						} else {
							System.out.println(s2);
						}

						if(s3.isPresent()) {
							System.out.println(s3.get());
						} else {
							System.out.println(s3);
						}

						if(s4.isPresent()) {
							System.out.println(s4.get());
						} else {
							System.out.println(s4);
						}

						if(s5.isPresent()) {
							System.out.println(s5.get());
						} else {
							System.out.println(s5);
						}
					}
				}

		O/P: 	Optional.empty
				value
				value_1
				Optional.empty
				[hi, there]

1. Common methods for Iterable and Collection interfaces :-
	- 	List<Person> person = ...;
		person.forEach(System.out::println); //This method of calling functions is called method reference

	-	person.removeIf(person -> person.getAge < 18);		//The condition passed as function is called predicate

2.	For List interface :-
	-	person.replaceAll(String::toUpperCase);
	- 	person.sort(
			Comparator.comparing(Person::getName).reversed()
												 .thenComparing(Person::getAge)
	);

3. 	For Map interface :-
	-	Map<City, List<Names>> = ...;
		map.forEach((city, list) ->
			System.out.println(city + ":" + list.size() + "people");
	)

	-	map.getOrDefault(boston, emptyList());	//It will either give associated value or return value passed  as second parameter

	-	map.putIfAbsent(boston, new ArrayList<Names>());	//It will add second parameter as value if key does not exist. It also returns new
															//the previous value associated with this key null if key was not present earlier

	-	map.replace(key, existingValue<optional>, newValue) //Replaces value for given key if matches provided existing value

	-	numbers.replaceAll((key, oldValue) -> oldValue * oldValue);

	-	courseMap.entrySet().removeIf(e - > e.getKey().equals("Java"));

	-	public static void main(String[] args) 
    { 
  
        // Create a Map and add some values 
        Map<String, String> map = new HashMap<>(); 
        map.put("Name", "Aman"); 
        map.put("Address", "Kolkata"); 
  
        // Print the map 
        System.out.println("Map: " + map); 
  
        // remap the values using compute() method 
        map.compute("Name", (key, val) 
                                -> val.concat(" Singh")); 
        map.compute("Address", (key, val) 
                                   -> val.concat(" West-Bengal")); 
  
        // print new mapping 
        System.out.println("New Map: " + map); 
    } 

	- 	Similar functions are computeIfAbsent and computeIfPresent with condition being that the passed function and BiFunction 
		respectively will be called to compute new associated value with passed parameter key if it is absent or is it is present.

	- map2.forEach(
		(key, value) ->
			map1.merge(key, value, 
						(existingValue, newValue) -> {
							existingValue.addAll(newValue);
							return existingValue;
						})
	);

4. When you create a stream, it is always a serial stream unless otherwise specified. To create a parallel stream, invoke the 
operation Collection.parallelStream. Alternatively, invoke the operation BaseStream.parallel. For example, the following statement 
calculates the average age of all male members in parallel:

	double average = roster
		.parallelStream()
		.filter(p -> p.getGender() == Person.Sex.MALE)
		.mapToInt(Person::getAge)
		.average()
		.getAsDouble();
	
	For such use cases you should use predicate in filter function that is associative.

5. Optional is a wrapper class like Integer that might be empty. Optional may contain a list as well.

6. Stream is a new interface in Java8 to perform map/filter/reduce operations on collections without creating new intermidiate collections
reducing the memory and processing overhead.
	-	Stream does not hold any data, it just processes data from a source.
	-	The size of the source is not known at runtime.
	-	EX: personList.stream()
						.map(p -> p.getAge())		//Converts objects list to integer list
						.filter(age -> age > 20)
						.forEach(System.out::println);
	-	Without a terminal operation like forEach or any call that does not retur stream the stream will never process the data.
	-	EX: personList.stream()
						.skip(2) //Does not considers first 2 elements 
						.limit(3) //Takes only 3 elements for stream manipulation
						.map(p -> p.getAge())		//Converts objects list to integer list
						.filter(age -> age > 20)
						.forEach(System.out::println);

	-	Match Reduction EX :
		boolean b = people.stream.allMatch(p -> p.getAge() > 20);  //Return true only if all elements are true for the condition.
		Similalry we have anyMatch() and noneMatch().	

	-	Find Reduction EX :
		Optional<Person> persons = persons.stream()
											.findAny(p -> p.getName().length() > 10);
		Similalry we have findFirst().

	- 	Reduce Reduction EX :
		The reduce reduction predicate should be associative in nature as this error will not be caught and only the answer will be 
		wrong. Below are its EX :
		int sumOfAges = people.stream()
								.reduce(0, (p1, p2) -> p1.getAge() + p2.getAge()); //here 0 is the identity element if no identity
																				   //element is present then we can provide output 
																				   //in optional.
		EX : Third type is using an Accumulator
		List<Integer> ages = people.stream()
									.reduce(
										new ArrayList<Integer>(), 
										(list, p) -> { 	list.add(p.getAge()) ; return list;},
										(list1, list2) -> { list1.addAll(list2); return list1;}
									);



====================================================SPRING - BOOT==================================================================

1. @EnableAutoConfiguration - Spring Boot automatically configures your application based on the dependencies you have added to the project
2. The entry point of the spring boot application is the class contains @SpringBootApplication annotation and the main method.
3. Spring Boot automatically scans all the components included in the project by using @ComponentScan annotation. You can add :-
@ComponentScan(
	basePackages = {name of base package}
	excludeFilters = {Classes you want to exclude}
)
4. 

====================================================FILE-HANDLING==================================================================
1. java.io package contains all classes related to getting value in and from a variable.Java I/O is organized into 4 base classes:
	- Reader(read from file) and Writer(write to a file)
	- i/p (read as binary) and o/p (write as a binary)stream
	- Utility classes: File and Path

2. File file = new File("dummyFile.txt"); //does not create file in disk just a file object
	Common methods for File class are:-
		file.isDirectory();
		file.isFile();
		file.exists();
		file.canRead();
		file.canWrite();
		file.canExecute();
		file.createNewFile();
    	file.mkdir();
    	file.delete();
		file.getName(); //file name
    	file.getParent(); //path where file is
		file.getPath(); //complete path with file name
		file.getAbsolutePath();
		file.getCanonicalPath(); //unique for each file

3. Path interface also has above mentioned methods with new addition like:
	- path.normalize(): Return value: This method returns the resulting path or this path if it does not 
		contain redundant name elements; an empty path is returned if this path does not have a root 
		component and all name elements are redundant.
	- path.toRealPath()
	- Files.isSameFile(path1, path2): Checks if both paths point to same location.
	- path.get(""): Converts string into path instance.

4. Java.io.Reader class in Java is an abstract class for reading character streams. The only methods 
   that a subclass must implement are read(char[], int, int) and close().
   public static void main(String[] args) throws Exception{
    Reader reader = new FileReader("./dummy.txt");
    char[] buffer = new char[10];
    if(reader.ready()) {
      reader.read(buffer, 0, 10);
      System.out.println(Arrays.toString(buffer));
    }
    reader.close();
  }
}

5. The reset() method of Reader Class in Java is used to reset the stream. After reset, if the stream 
has been marked, then this method attempts to reposition it at the mark, else it will try to position 
it to the starting.

	class GFG { 
    public static void main(String[] args) 
    { 
		try { 
            String str = "GeeksForGeeks"; 
            Reader reader = new StringReader(str); 
            int ch; 
            for (int i = 0; i < 10; i++) { 
                ch = reader.read(); 
                System.out.print((char)ch); 
            } 
            System.out.println(); 
            reader.mark(5); 
            reader.reset(); 
            for (int i = 0; i < 5; i++) { 
                ch = reader.read(); 
				reader.skip(1); //Skip one character every time
                System.out.print((char)ch); 
            } 
        }
6. Sample program for creating files dynamically according to file size:

import java.io.File;
import java.io.FileWriter;
import java.io.Writer;

class java_rough {
  public static void main(String[] args) throws Exception{
   File file = new File("./dummy.txt");

   if(!file.exists()) {
    file.createNewFile();
    System.out.println("Created " + file.getName());
   }

    int count = 0;
    long size = 0l;
    String fileName;
    CharSequence fileContent = "Sample data to be written";
    Writer  writer = new FileWriter(file);
    
    while(count < 10) {
      size = file.length();
      if(size > 10) {
        count++;
        fileName = "dummy" + count;
        file = new File("./" + fileName + ".txt");
        file.createNewFile();
        writer = new FileWriter(file);
        System.out.println("Created new file" + fileName + ".txt" + " as size is " + size);
        size = 0;
      } else {
        writer.append(fileContent);
        writer.flush();
      }
    }
    writer.close();
  }
}

7. The Properties class represents a persistent set of properties. The Properties can be saved to a stream or loaded from a stream.

	- Properties is a subclass of Hashtable.
	- It is used to maintain list of value in which the key is a string and the value is also a string.
	- One useful capability of the Properties class is that you can specify a default property that will be returned if no value is 
	  associated with a certain key.
	- Multiple thread can share a single properties object without the need of external synchronisation.

8. EX: Setting/Retrieving properties
		import java.util.Properties;
		class java_rough {
			public static void main(String[] args) {
				Properties properties = new Properties();
				properties.setProperty("name", "vishal");
				properties.setProperty("age", "24");

				System.out.println("details are: " + properties.getProperty("name") 
												+ ", " + properties.getProperty("age") 
												+ ", " + properties.getProperty("job", "Engineer"));
			}
		}
		
9. EX: Stroing properties in file
				public static void main(String[] args) throws Exception {
						Properties properties = new Properties();
						properties.setProperty("name", "vishal");
						properties.setProperty("age", "24");
						//Paths creates files automatically 
						try(Writer writer = Files.newBufferedWriter(Paths.get("./newProperties.txt"))) { 
							properties.store(writer, "My details");
						}

						System.out.println("details are: " + properties.getProperty("name") 
														+ ", " + properties.getProperty("age") 
														+ ", " + properties.getProperty("job", "Engineer"));
					}

	File created : 	#My details
					#Sun Jan 26 10:09:48 IST 2020
					name=vishal
					age=24

4. EX: Reading from a file 
					public static void main(String[] args) throws Exception {
							Properties properties = new Properties();
							try(Reader reader = Files.newBufferedReader(Paths.get("./newProperties.txt"))) {
								properties.load(reader);
							}

							System.out.println("details are: " + properties.getProperty("name") 
															+ ", " + properties.getProperty("age") 
															+ ", " + properties.getProperty("job", "Engineer"));
					}

====================================================MULTI-THREADDING==================================================================

1. Runnable Interface: Enables a classes method to run as thread in calling method
					   EX: 	public class ExampleClass implements Runnable {  
						
							@Override  
							public void run() {  
								System.out.println("Thread has ended");  
							}  
						
							public static void main(String[] args) {  
								ExampleClass ex = new ExampleClass();  
								Thread t1= new Thread(ex);  
								t1.start();  
								System.out.println("Hi");  
							}  
						}  

2. Callable: The Callable interface is designed to define a task that returns a result and may throw an exception. This interface 
	also contains a single, no-argument method, called call (), to be overridden by the implementors of this interface. This method 
	is similar to the run () method of the Runnable interface, except that it returns a value and can throw a checked exception.

3. Future: The Future interface is a generic interface that represents the value returned from an asynchronous computation. 
   It contains methods to check if the computation has been completed or wait for it, retrieve the result.

4. A java.util.concurrent.ExecutorService interface is a subinterface of Executor interface, and adds features to manage 
   the lifecycle, both of the individual tasks and of the executor itself.
EX:  
			public class CallableMain {
			public static void main(String[] args)
					throws InterruptedException, ExecutionException {
				ExecutorService service = Executors.newSingleThreadExecutor();
				CallableFactorialTask task = new CallableFactorialTask(5);
				Future<Integer> f = service.submit(task);
				Integer val = f.get();
				System.out.println(val);
				service.shutdown();
			}
			}
			class CallableFactorialTask implements Callable<Integer> {
			private int num = 0;
			public CallableFactorialTask(int num){
				this.num = num;
			}
			@Override
			public Integer call() throws Exception {
				int prod = 1;
				for (int i = 2; i <= num; i++)
					prod *= i;
				return prod;
			}
			}

5. Synchronized Method: If you declare any method as synchronized (synchronized void printTable(int n)), it is known as synchronized method. Synchronized method is used to 
   lock an object for any shared resource. When a thread invokes a synchronized method, it automatically acquires the lock for that 
   object and releases it when the thread completes its task.

6. Synchronized statements: Synchronized block is used to lock an object for any shared resource. Scope of synchronized block is 
   smaller than the method.
	EX:
			void printTable(int n){  
			synchronized(this){//synchronized block  
				for(int i=1;i<=5;i++){  
				System.out.println(n*i);  
				try{  
				Thread.sleep(400);  
				}catch(Exception e){System.out.println(e);}  
				}  
			}  
			}//end of the method  

====================================================SQL AND NO-SQL==================================================================			

1. Analogies MySQL and Mongo
	Table : Collection
	Primary Key : _id field
	Tuple : BSON Document
	Column : Field
	Join : Embedding and Linking

2. Differences MySQL and Mongo
	Uses Schema : Schema Less
	Relies on relations : Does no rely on relations
	Stores data in multiple related tables : Stores data in a merged/consolidated manner as BSON Document
	Horizontal scaling is difficult : Horizontal scaling is easy
	Limitations for large number read and write queries per second :  Good performance for large number read and write queries per second

3. Adding mongo db to SpringBoot App: https://springframework.guru/configuring-spring-boot-for-mongo/

4. https://www.javaworld.com/article/3373652/java-persistence-with-jpa-and-hibernate-part-1-entities-and-relationships.html
   JPA: Java Persistence API Hibernate is one implementation of JPA. Hibernate is an object-relational mapping (ORM) tool. JPA offers a 
   standard way to annotate objects so that they can be mapped and stored in a relational database. 

5. The Java Persistence API is a specification, not an implementation: it defines a common abstraction that you can use in your code to 
   interact with ORM products. 

6. The @Entity annotation is a marker annotation, which is used to discover persistent entities. If you wanted to map this entity to 
   another table (and, optionally, a specific schema) you could use the @Table annotation to do that. able Schema is a specification 
   for providing a “schema” (similar to a database schema) for tabular data. This information includes the expected type of each 
   value in a column (“string”, “number”, “date”, etc.), constraints on the value and the expected format of the data
	EX: @Entity
		@Table(name="BOOKS", schema="PUBLISHING")
		public class Book {
		...
		}
	
7. Fields are mapped to columns of the table. To override the column value use @Column annotation.
		EX: @Entity
			@Table(name="BOOKS")
			public class Book {
			private String name;
			@Column(name="ISBN_NUMBER")
			private String isbn;
			...
			}

8.  In JPA, we use the @Id annotation to designate a field to be the table's primary key. The primary key is required to be a 
	Java primitive type, a primitive wrapper, such as Integer or Long, a String, a Date, a BigInteger, or a BigDecimal.
		EX: @Entity
			@Table(name="BOOKS")
			public class Book {
			@Id
			private Integer id;
			private String name;
			@Column(name="ISBN_NUMBER")
			private String isbn;
			...
			}

9. Annotations for mapping for Entity relations:
	@OneToOne: @Entity
				public class User {
				@Id
				private Integer id;
				private String email;
				private String name;
				private String password;
				@OneToOne(mappedBy="user")
				private UserProfile profile;
				...
				}
		Mapped to
				@Entity
				public class UserProfile {
				@Id
				private Integer id;
				private int age;
				private String gender;
				private String favoriteColor;
				@OneToOne
				private User user;
				...
				}

	@ManyToOne: @Entity
				public class Book {
					@Id
					private Integer id;
					private String name;
					@ManyToOne
					@JoinColumn(name="AUTHOR_ID")
					private Author author;
					...
				}
		Author can have multiple books but book has one Author scenario
				@Entity
				public class Author {
					@Id
					@GeneratedValue
					private Integer id;
					private String name;
					@OneToMany(mappedBy = "author")
					private List<Book> books = new ArrayList<>();
					...
				}

	@ManyToMany:@Entity
				public class Book {
					@Id
					private Integer id;
					private String name;
					@ManyToMany
					@JoinTable(name="BOOK_AUTHORS",
							joinColumns=@JoinColumn(name="BOOK_ID"),
							inverseJoinColumns=@JoinColumn(name="AUTHOR_ID"))
					private Set<Author> authors = new HashSet<>();
					...
				}
		Author can have multiple books and book can have multiple Authors scenario
				@Entity
				public class Author {
					@Id
					@GeneratedValue
					private Integer id;
					private String name;
					@ManyToMany(mappedBy = "author")
					private Set<Book> books = new HashSet<>();
					...
				}

==================================================GIT-COMMANDS===================================================================

1. 	Running the following command will revert the last two commits: git revert HEAD~2..HEAD
	Alternatively, one can always checkout the state of a particular commit from the past, and commit it anew.

2.	To squash the last N commits of the current branch, run the following command (with {N} replaced with the number of commits 
	that you want to squash):	git rebase -i HEAD~{N}
	Upon running this command, an editor will open with a list of these N commit messages, one per line. Each of these lines will 
	begin with the word “pick”. Replacing “pick” with “squash” or “s” will tell Git to combine the commit with the commit before it. 
	To combine all N commits into one, set every commit in the list to be squash except the first one. Upon exiting the editor, and 
	if no conflict arises, git rebase will allow you to create a new commit message for the new combined commit.

3. 	git diff-tree -r {hash}:	Given the commit hash, this will list all the files that were changed or added in that commit. 
	The -r flag makes the command list individual files, rather than collapsing them into root directory names only.

4.	git cherry-pick {hash of that commit}:	In spite of applying the same changes, it will be a new commit with a new hash 
	because the changes are applied to a different destination.

5. 	git fetch only downloads new data from a remote repository, but it doesn’t integrate any of the downloaded data into your 
	working files. All it does is provide a view of this data.

6.	git pull downloads as well as merges the data from a remote repository into your local working files. It may also lead to 
	merge conflicts if your local changes are not yet committed. Use the git stash command to hide your local changes.

===============================================================DOCKER COMMANDS====================================================
COMMON:	docker ps, docker ps -a, docker stop, docker images, docker rm <container id>, docker rmi <image-id>
1.	docker run -it -d <image name>: This command is used to create a container from an image

2. 	Usage: docker exec -it <container id> bash: This command is used to access the running container

3.	docker kill <container id>: The difference between ‘docker kill’ and ‘docker stop’ is that ‘docker stop’ gives the container 
	time to shutdown gracefully, in situations when it is taking too much time for getting the container to stop, one can opt to 
	kill it

4.	docker commit <conatainer id> <username/imagename>: This command creates a new image of an edited container on the local system

5.	docker push <username/image name>: This command is used to push an image to the docker hub repository

6.	docker build <path to docker file>: This command is used to build an image from a specified docker file

================================================================KAFKA================================================================

1. 	Topics in Kafka are data streams, identified by Topic-name. Each topic has partitions and messages are devided in these 
	partitions for a topic. Topics stored data in ordered manner by using a increasing Offset value for each message.

2. 	Data is randomly assigned among partitions in for a topic, until a key is used. Data order is only guarenteed for a partition
	using offsets. Data once written on a partition cannot be changes ie it is immutable.

3.	Kafka broker is the server that stores partitions of kafka topics. A collection of brokers is called a kafka cluster and 
	once connecting to a bootstrap broker which can be any one of the cluster, connection will be made for the while cluster.
	Each broker is identified by its ID (integer).

4. 	At a time only one broker is leader for a partition. The same broker will not contain its In Sync Replica(ISR) so that if it 
	goes down the broker with ISR becomes leader.

5. 	Producer can opt for ACKS in the following 3 ways:
	-	acks = 0: No acks waiting done by producer.
	-	acks = 1: Producer waits for leader acks.
	-	acks = all: Producer waits for leader and replicas acks.

6. 	Producer can use keys + Message to ensure partition to which the message is sent, else it is sent using Round Robin.

7. 	Consumers read as groups, where each consumer is reading from fixed partition. If your config has more consumer in group than
	partition from the topic then one group will be left idle.

8. 	Consumers have 3 delivery semantics for commiting offsets:
	-	At most once: 	commiting offset as soon as message is received. Message will be lost if processing fails.
	-	At least once: 	commiting offset after processing message. Message is reprocessed if processing fails, so system should be 
						Idempotent.
	-	Exactly once:	Is achieved using kafka stream APIs
9. 	Github: https://github.com/simplesteph/kafka-beginners-course/tree/master/kafka-basics/src/main/java/kafka/tutorial1

10. Using below method you can add Kafka metadata for your logging:
				producer.send(record, new Callback() {  //A callback interface that the user can implement to allow code to
														// execute when the request is complete.
					public void onCompletion(RecordMetadata recordMetadata, Exception e) {
						// executes every time a record is successfully sent or an exception is thrown
						if (e == null) {
							// the record was successfully sent
							logger.info("Received new metadata. \n" +
									"Topic:" + recordMetadata.topic() + "\n" +
									"Partition: " + recordMetadata.partition() + "\n" +
									"Offset: " + recordMetadata.offset() + "\n" +
									"Timestamp: " + recordMetadata.timestamp());
						} else {
							logger.error("Error while producing", e);
						}
                }

11.	You can add key to your kafka message by: 
				ProducerRecord<String, String> record =	new ProducerRecord<String, String>(topic, key, value);
Then sending this record as shown above.

12. After setting Consumer properties you can set consumer to subscribe to topic and log the messages and metadata with it as
	shown below:

	KafkaConsumer<String, String> consumer = new KafkaConsumer<String, String>(properties);

        // subscribe consumer to our topic(s)
        consumer.subscribe(Arrays.asList(topic));

        // poll for new data
        while(true){
            ConsumerRecords<String, String> records =
                    consumer.poll(Duration.ofMillis(100)); // new in Kafka 2.0.0

            for (ConsumerRecord<String, String> record : records){
                logger.info("Key: " + record.key() + ", Value: " + record.value());
                logger.info("Partition: " + record.partition() + ", Offset:" + record.offset());
            }
        }

13. Kafka allows you to Assign a topic and partition and seek messages for it from a particular offset.
EX: https://github.com/simplesteph/kafka-beginners-course/blob/master/kafka-basics/src/main/java/kafka/tutorial1/ConsumerDemoAssignSeek.java 

OPEN QUESTIONS:
1. Can a consumer be coded to read from a paeticular partition?
2. ACKS stratergy, comiting offsets, using callback, keys, Assign and Seek

	










